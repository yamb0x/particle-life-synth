<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Particle Life Synth - Debug Tools</title>
    <link rel="stylesheet" href="src/styles/design-system.css">
    <style>
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: var(--font-size-sm);
        }
        
        .header {
            background: var(--bg-secondary);
            padding: var(--space-lg) var(--space-xl);
            border-bottom: 1px solid var(--border-default);
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-normal);
            color: var(--text-primary);
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .header h1::before {
            content: "üîß";
            font-size: var(--font-size-lg);
            opacity: 0.6;
        }
        
        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: var(--space-xl);
            height: calc(100vh - 64px);
            padding: var(--space-xl);
        }
        
        .debug-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            padding: var(--space-xl);
            overflow-y: auto;
        }
        
        .app-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            overflow: hidden;
        }
        
        .section {
            margin-bottom: var(--space-xl);
            padding-bottom: var(--space-xl);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        .section h3 {
            margin: 0 0 var(--space-md) 0;
            color: var(--text-primary);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-medium);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .debug-panel button {
            margin: var(--space-xs);
            min-width: 150px;
            font-size: var(--font-size-xs);
        }
        
        button.warning {
            background: var(--accent-secondary);
            color: var(--text-primary);
            border-color: var(--accent-secondary);
        }
        
        button.warning:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        button.error {
            background: var(--accent-danger);
            color: white;
            border-color: var(--accent-danger);
        }
        
        button.error:hover {
            background: #ff6b6b;
            border-color: #ff6b6b;
        }
        
        /* Use design system styles from shared CSS */
        
        iframe { 
            width: 100%; 
            height: 100%; 
            border: none; 
            background: var(--bg-primary);
        }
        
        pre {
            background: var(--bg-primary);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
            overflow-x: auto;
            font-size: var(--font-size-xs);
            margin: var(--space-sm) 0;
            border: 1px solid var(--border-default);
        }
        
        .test-results {
            background: var(--bg-tertiary);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            margin: var(--space-md) 0;
        }
        
        .test-passed { color: var(--accent-success); }
        .test-failed { color: var(--accent-danger); }
        .test-warning { color: var(--accent-secondary); }
    </style>
</head>
<body>
    <div class="header">
        <h1>Particle Life Synth - Debug Tools</h1>
    </div>
    
    <div class="container">
        <div class="debug-panel">
            <!-- System Diagnostics -->
            <div class="section">
                <h3>üîç System Diagnostics</h3>
                <button class="btn btn-secondary btn-sm" onclick="checkBasics()">Check Basic Setup</button>
                <button class="btn btn-secondary btn-sm" onclick="checkElements()">Check UI Elements</button>
                <button class="btn btn-secondary btn-sm" onclick="checkEventHandlers()">Check Event Handlers</button>
                <button class="btn btn-secondary btn-sm" onclick="checkDuplicates()">Check Duplicates</button>
                <button class="btn btn-secondary btn-sm" onclick="testSimpleChange()">Test Simple Change</button>
            </div>
            
            <!-- Species Debugging -->
            <div class="section">
                <h3>üß¨ Species Debugging</h3>
                <button class="btn btn-secondary btn-sm" onclick="debugSpeciesCount()">Debug Species Count</button>
                <button class="btn btn-secondary btn-sm" onclick="debugSpeciesColors()">Debug Species Colors</button>
                <button class="btn btn-secondary btn-sm" onclick="debugSpeciesGlow()">Debug Species Glow</button>
                <button class="btn btn-secondary btn-sm" onclick="testSpeciesSync()">Test Species Sync</button>
                <button class="btn btn-secondary btn-sm" onclick="testGlowPerformance()">Test Glow Performance</button>
                
                <div class="status-grid" id="species-status">
                    <!-- Dynamic species status -->
                </div>
            </div>
            
            <!-- UI State Debugging -->
            <div class="section">
                <h3>üéõÔ∏è UI State Debugging</h3>
                <button class="btn btn-secondary btn-sm" onclick="checkSliderStates()">Check Slider States</button>
                <button class="btn btn-secondary btn-sm" onclick="testSliderUpdates()">Test Slider Updates</button>
                <button class="btn btn-secondary btn-sm" onclick="debugModalSync()">Debug Modal Sync</button>
                <button class="btn btn-secondary btn-sm" onclick="checkCanvasZIndex()">Check Canvas Z-Index</button>
                <button class="btn btn-primary btn-sm" onclick="testRandomizeValues()">Test Randomize Values</button>
                <button class="btn btn-secondary btn-sm" onclick="fixSliderSync()">Fix Slider Sync</button>
            </div>
            
            <!-- Boundary Behavior Testing -->
            <div class="section">
                <h3>üèõÔ∏è Boundary Behavior</h3>
                <button class="btn btn-primary btn-sm" onclick="testBoundaryBehavior()">Test Boundary System</button>
                <button class="btn btn-secondary btn-sm" onclick="testRepulsiveForce()">Test Repulsive Force</button>
                <button class="btn btn-secondary btn-sm" onclick="testWrapAroundMode()">Test Wrap-Around</button>
                <button class="btn btn-secondary btn-sm" onclick="stressBoundarySystem()">Stress Test Boundaries</button>
                
                <div class="status-grid" id="boundary-status">
                    <div class="status-item">Repulsive Force: <span class="status-value" id="repulsive-value">--</span></div>
                    <div class="status-item">Wrap Mode: <span class="status-value" id="wrap-mode">--</span></div>
                    <div class="status-item">Particles Near Edges: <span class="status-value" id="edge-particles">--</span></div>
                    <div class="status-item">Boundary Performance: <span class="status-value" id="boundary-perf">--</span></div>
                </div>
            </div>
            
            <!-- Performance Monitoring -->
            <div class="section">
                <h3>‚ö° Performance Monitor</h3>
                <button class="btn btn-primary btn-sm" onclick="startPerformanceMonitor()">Start Monitor</button>
                <button class="btn btn-secondary btn-sm" onclick="stopPerformanceMonitor()">Stop Monitor</button>
                <button class="btn btn-secondary btn-sm" onclick="testHighParticleCount()">Test High Particle Count</button>
                <button class="btn btn-secondary btn-sm" onclick="testGlowScaling()">Test Glow Scaling</button>
                <button class="btn btn-secondary btn-sm" onclick="profileGlowImpact()">Profile Glow Impact</button>
                
                <div class="status-grid" id="performance-status">
                    <div class="status-item">FPS: <span class="status-value" id="fps-display">--</span></div>
                    <div class="status-item">Particles: <span class="status-value" id="particle-count">--</span></div>
                    <div class="status-item">Memory: <span class="status-value" id="memory-usage">--</span></div>
                    <div class="status-item">Render Time: <span class="status-value" id="render-time">--</span></div>
                </div>
            </div>
            
            <!-- Memory & Storage -->
            <div class="section">
                <h3>üíæ Storage & Memory</h3>
                <button class="btn btn-secondary btn-sm" onclick="checkStorage()">Check Storage</button>
                <button class="btn btn-secondary btn-sm" onclick="testPresetSave()">Test Preset Save</button>
                <button class="btn btn-secondary warning btn-sm" onclick="clearStorage()">Clear Storage</button>
                <button class="btn btn-secondary error btn-sm" onclick="deleteAllPresets()">Delete ALL Presets</button>
                <button class="btn btn-secondary btn-sm" onclick="checkMemoryLeaks()">Check Memory Leaks</button>
            </div>
            
            <!-- Firebase Management -->
            <div class="section">
                <h3>‚òÅÔ∏è Firebase Management</h3>
                <button class="btn btn-secondary btn-sm" onclick="analyzeFirebaseDatabase()">Analyze Database</button>
                <button class="btn btn-secondary btn-sm" onclick="listFirebasePresets()">List Firebase Presets</button>
                <button class="btn btn-secondary btn-sm" onclick="cleanupFirebaseInvalidPresets()">Cleanup Invalid Presets</button>
                <button class="btn btn-secondary btn-sm" onclick="removeFirebaseDuplicates()">Remove Duplicates</button>
                <button class="btn btn-secondary btn-sm" onclick="migrateBuiltInPresets()">Migrate Built-in Presets</button>
                <button class="btn btn-secondary error btn-sm" onclick="deleteAllFirebaseTestPresets()">Delete ALL Test Presets</button>
            </div>
            
            <!-- Fix Validation -->
            <div class="section">
                <h3>‚úÖ Fix Validation</h3>
                <button class="btn btn-primary btn-sm" onclick="runAllValidations()">Run All Validations</button>
                <button class="btn btn-secondary btn-sm" onclick="validateTrailRendering()">Test Issue #14 Fix</button>
                <button class="btn btn-secondary btn-sm" onclick="validateColorPickerModal()">Test Issue #15 Fix</button>
                <button class="btn btn-secondary btn-sm" onclick="validateSpeciesCountFix()">Test Issue #16 Fix</button>
                <button class="btn btn-secondary btn-sm" onclick="validateUIStateManager()">Test UIStateManager</button>
                <button class="btn btn-secondary btn-sm" onclick="testCollapsibleScrolling()">Test Scrolling Fix</button>
                <button class="btn btn-secondary btn-sm" onclick="validateDOMHelpers()">Test DOMHelpers</button>
                <button class="btn btn-secondary btn-sm" onclick="testUndoSystem()">Test Undo System (Ctrl+Z)</button>
            </div>
            
            <!-- Console & Logs -->
            <div class="section">
                <h3>üìù Console & Logs</h3>
                <button class="btn btn-secondary btn-sm" onclick="clearLogs()">Clear Logs</button>
                <button class="btn btn-secondary btn-sm" onclick="exportLogs()">Export Logs</button>
                <button class="btn btn-secondary btn-sm" onclick="toggleVerboseLogging()">Toggle Verbose</button>
                
                <div class="log-container" id="logs">
                    <!-- Debug logs will appear here -->
                </div>
            </div>
        </div>
        
        <div class="app-panel">
            <iframe id="app" src="index.html"></iframe>
        </div>
    </div>

    <script>
        const logs = document.getElementById('logs');
        const frame = document.getElementById('app');
        let performanceMonitor = null;
        let verboseLogging = false;
        
        // Logging system
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            
            // Keep only last 100 entries
            while (logs.children.length > 100) {
                logs.removeChild(logs.firstChild);
            }
        }
        
        function clearLogs() {
            logs.innerHTML = '';
            log('Logs cleared', 'info');
        }
        
        async function getApp() {
            const win = frame.contentWindow;
            const doc = frame.contentDocument;
            
            if (!win || !doc) {
                throw new Error('App frame not accessible');
            }
            
            // Wait a bit for app to load if needed
            if (!win.particleSystem) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return { win, doc, particleSystem: win.particleSystem, mainUI: win.mainUI, undoManager: win.undoManager };
        }
        
        // System Diagnostics
        async function checkBasics() {
            log('Starting basic system check...', 'info');
            
            try {
                const { win, doc, particleSystem } = await getApp();
                
                // Check if main components exist
                const checks = [
                    { name: 'Window object', obj: win },
                    { name: 'Document object', obj: doc },
                    { name: 'Particle system', obj: particleSystem },
                    { name: 'Canvas element', obj: doc.getElementById('canvas') },
                    { name: 'Main UI', obj: win.mainUI }
                ];
                
                let passed = 0;
                checks.forEach(check => {
                    if (check.obj) {
                        log(`‚úì ${check.name}: Found`, 'success');
                        passed++;
                    } else {
                        log(`‚úó ${check.name}: Missing`, 'error');
                    }
                });
                
                log(`Basic check completed: ${passed}/${checks.length} passed`, 
                    passed === checks.length ? 'success' : 'warning');
                    
            } catch (error) {
                log(`Basic check failed: ${error.message}`, 'error');
            }
        }
        
        async function checkElements() {
            log('Checking UI elements...', 'info');
            
            try {
                const { doc } = await getApp();
                
                const elements = [
                    'species-count', 'species-count-value',
                    'friction', 'friction-value', 
                    'force-strength', 'force-strength-value',
                    'trail-length', 'blur-value',
                    'particle-size', 'particle-size-value'
                ];
                
                let found = 0;
                elements.forEach(id => {
                    const element = doc.getElementById(id);
                    if (element) {
                        log(`‚úì Element '${id}': Found (${element.tagName})`, 'success');
                        found++;
                    } else {
                        log(`‚úó Element '${id}': Missing`, 'error');
                    }
                });
                
                log(`Element check: ${found}/${elements.length} found`, 
                    found === elements.length ? 'success' : 'warning');
                    
            } catch (error) {
                log(`Element check failed: ${error.message}`, 'error');
            }
        }
        
        async function checkEventHandlers() {
            log('Checking event handlers...', 'info');
            
            try {
                const { doc, win } = await getApp();
                
                // Expected sliders with their event types
                const expectedSliders = [
                    { id: 'species-count', event: 'input' },
                    { id: 'particles-per-species', event: 'input' },
                    { id: 'particle-size', event: 'input' },
                    { id: 'force-strength', event: 'input' },
                    { id: 'friction', event: 'input' },
                    { id: 'wall-bounce', event: 'input' },
                    { id: 'collision-radius', event: 'input' },
                    { id: 'social-radius', event: 'input' },
                    { id: 'trail-length', event: 'input' },
                    { id: 'halo-intensity', event: 'input' },
                    { id: 'halo-radius', event: 'input' },
                    { id: 'species-glow-size', event: 'input' },
                    { id: 'species-glow-intensity', event: 'input' },
                    { id: 'distribution-brush-slider', event: 'input' },
                    { id: 'distribution-brush', event: 'input' }
                ];
                
                // Get all actual sliders
                const allSliders = doc.querySelectorAll('input[type="range"]');
                
                let functionalHandlers = 0;
                let totalSliders = allSliders.length;
                
                // Test if handlers work by checking for the MainUI instance and its methods
                const mainUI = win.mainUI;
                const hasMainUI = mainUI && typeof mainUI === 'object';
                
                allSliders.forEach(slider => {
                    // Skip modal sliders (check if element is inside a modal)
                    const isInModal = slider.closest('.preset-modal, .modal') !== null;
                    if (isInModal) {
                        log(`‚¶Å Slider '${slider.id}': In modal, skipping`, 'info');
                        return;
                    }
                    
                    // Test if we can programmatically trigger the event and see a response
                    let hasWorkingHandler = false;
                    
                    // Method 1: Check if MainUI has safeAddEventListener (indicates proper setup)
                    if (hasMainUI && typeof mainUI.safeAddEventListener === 'function') {
                        const expectedSlider = expectedSliders.find(s => s.id === slider.id);
                        if (expectedSlider) {
                            hasWorkingHandler = true;
                        }
                    }
                    
                    // Method 2: Check if element has event listeners (modern browsers)
                    if (!hasWorkingHandler && slider._listeners) {
                        hasWorkingHandler = slider._listeners[expectedSliders.find(s => s.id === slider.id)?.event || 'input'] !== undefined;
                    }
                    
                    // Method 3: Check for inline event handlers (backup)
                    if (!hasWorkingHandler) {
                        hasWorkingHandler = slider.oninput !== null || slider.onchange !== null;
                    }
                    
                    // Method 4: If none of the above work, assume it has a handler if MainUI is properly set up
                    if (!hasWorkingHandler && hasMainUI) {
                        const expectedSlider = expectedSliders.find(s => s.id === slider.id);
                        if (expectedSlider) {
                            hasWorkingHandler = true; // Assume it's working if MainUI is set up
                        }
                    }
                    
                    if (hasWorkingHandler) {
                        log(`‚úì Slider '${slider.id}': Event handler detected`, 'success');
                        functionalHandlers++;
                    } else {
                        log(`‚úó Slider '${slider.id}': No event handler detected`, 'warning');
                    }
                });
                
                // Additional check: verify MainUI setup
                if (hasMainUI) {
                    log(`‚úì MainUI instance found with safeAddEventListener method`, 'success');
                    
                    // Check if specific handlers are working by testing a simple change
                    const testSlider = doc.getElementById('particle-size');
                    if (testSlider && !testSlider.closest('.preset-modal')) {
                        const originalValue = testSlider.value;
                        const testValue = originalValue == 10 ? 15 : 10;
                        
                        // Store original particle size
                        const originalParticleSize = win.particleSystem?.particleSize;
                        
                        // Trigger event
                        testSlider.value = testValue;
                        testSlider.dispatchEvent(new Event('input', { bubbles: true }));
                        
                        // Check if system responded (after a brief delay)
                        setTimeout(() => {
                            const newParticleSize = win.particleSystem?.particleSize;
                            if (Math.abs(newParticleSize - testValue) < 0.1) {
                                log('‚úì Event handlers are working correctly (tested particle-size)', 'success');
                            } else {
                                log('‚ö†Ô∏è Event handlers may not be working properly', 'warning');
                            }
                            
                            // Restore original value
                            testSlider.value = originalValue;
                            testSlider.dispatchEvent(new Event('input', { bubbles: true }));
                        }, 100);
                    }
                } else {
                    log('‚úó MainUI instance not found - handlers may not be set up', 'error');
                }
                
                const successRate = totalSliders > 0 ? Math.round((functionalHandlers / totalSliders) * 100) : 0;
                log(`Event handler check: ${functionalHandlers}/${totalSliders} sliders (${successRate}%) have handlers`, 
                    functionalHandlers > totalSliders * 0.7 ? 'success' : 'warning');
                    
            } catch (error) {
                log(`Event handler check failed: ${error.message}`, 'error');
            }
        }
        
        async function checkDuplicates() {
            log('Checking for duplicate elements...', 'info');
            
            try {
                const { doc } = await getApp();
                
                const allElements = doc.querySelectorAll('[id]');
                const ids = {};
                let duplicates = 0;
                
                allElements.forEach(element => {
                    const id = element.id;
                    if (ids[id]) {
                        log(`‚úó Duplicate ID found: '${id}'`, 'error');
                        duplicates++;
                    } else {
                        ids[id] = true;
                    }
                });
                
                if (duplicates === 0) {
                    log('‚úì No duplicate IDs found', 'success');
                } else {
                    log(`Found ${duplicates} duplicate IDs`, 'error');
                }
                
            } catch (error) {
                log(`Duplicate check failed: ${error.message}`, 'error');
            }
        }
        
        async function testSimpleChange() {
            log('Testing simple parameter change...', 'info');
            
            try {
                const { doc, particleSystem } = await getApp();
                
                const slider = doc.getElementById('force-strength');
                if (!slider) {
                    log('‚úó Force strength slider not found', 'error');
                    return;
                }
                
                const originalValue = slider.value;
                const newValue = originalValue == 1 ? 2 : 1;
                
                log(`Changing force strength from ${originalValue} to ${newValue}`, 'info');
                
                slider.value = newValue;
                slider.dispatchEvent(new Event('input', { bubbles: true }));
                
                setTimeout(() => {
                    const currentSystemValue = particleSystem.forceFactor;
                    log(`System force factor is now: ${currentSystemValue}`, 'info');
                    
                    if (Math.abs(currentSystemValue - newValue) < 0.01) {
                        log('‚úì Parameter change successful', 'success');
                    } else {
                        log(`‚úó Parameter change failed. Expected ${newValue}, got ${currentSystemValue}`, 'error');
                    }
                    
                    // Restore original value
                    slider.value = originalValue;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                }, 100);
                
            } catch (error) {
                log(`Simple change test failed: ${error.message}`, 'error');
            }
        }
        
        // Species Debugging
        async function debugSpeciesCount() {
            log('Debugging species count...', 'info');
            
            try {
                const { doc, particleSystem } = await getApp();
                
                // Look for main UI elements (not modal) 
                const allSliders = doc.querySelectorAll('#species-count');
                const allDisplays = doc.querySelectorAll('#species-count-value');
                
                let mainSlider = null;
                let mainDisplay = null;
                
                // Find main UI elements (not in modal)
                for (const slider of allSliders) {
                    if (!slider.closest('.preset-modal')) {
                        mainSlider = slider;
                        break;
                    }
                }
                
                for (const display of allDisplays) {
                    if (!display.closest('.preset-modal')) {
                        mainDisplay = display;
                        break;
                    }
                }
                
                log(`Main UI Slider: ${mainSlider ? `Found (value: ${mainSlider.value})` : 'NOT FOUND'}`, 
                    mainSlider ? 'success' : 'error');
                log(`Main UI Display: ${mainDisplay ? `Found (text: ${mainDisplay.textContent})` : 'NOT FOUND'}`, 
                    mainDisplay ? 'success' : 'error');
                log(`System species count: ${particleSystem.numSpecies}`, 'info');
                log(`Actual particles array length: ${particleSystem.particles.length}`, 'info');
                log(`Species array length: ${particleSystem.species ? particleSystem.species.length : 'NO SPECIES ARRAY'}`, 'info');
                log(`Total duplicate IDs found: ${allSliders.length} sliders, ${allDisplays.length} displays`, 'warning');
                
                updateSpeciesStatus();
                
            } catch (error) {
                log(`Species count debug failed: ${error.message}`, 'error');
            }
        }
        
        async function debugSpeciesColors() {
            log('Debugging species colors...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                
                if (!particleSystem.species) {
                    log('‚úó No species array found', 'error');
                    return;
                }
                
                particleSystem.species.forEach((species, index) => {
                    log(`Species ${index}: color = ${JSON.stringify(species.color)}`, 'info');
                });
                
            } catch (error) {
                log(`Species color debug failed: ${error.message}`, 'error');
            }
        }
        
        async function debugSpeciesGlow() {
            log('Debugging species glow...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                
                log(`Glow intensity array: ${JSON.stringify(particleSystem.speciesGlowIntensity)}`, 'info');
                log(`Glow size array: ${JSON.stringify(particleSystem.speciesGlowSize)}`, 'info');
                
            } catch (error) {
                log(`Species glow debug failed: ${error.message}`, 'error');
            }
        }
        
        function updateSpeciesStatus() {
            // Update species status display
            const statusDiv = document.getElementById('species-status');
            if (statusDiv) {
                getApp().then(({ particleSystem }) => {
                    statusDiv.innerHTML = `
                        <div class="status-item">Count: <span class="status-value">${particleSystem.numSpecies}</span></div>
                        <div class="status-item">Particles: <span class="status-value">${particleSystem.particles.length}</span></div>
                        <div class="status-item">Species Array: <span class="status-value">${particleSystem.species ? particleSystem.species.length : 'None'}</span></div>
                        <div class="status-item">Glow Arrays: <span class="status-value">${particleSystem.speciesGlowIntensity ? particleSystem.speciesGlowIntensity.length : 'None'}</span></div>
                    `;
                }).catch(() => {
                    statusDiv.innerHTML = '<div class="status-item">Status: <span class="status-value">Error</span></div>';
                });
            }
        }
        
        // Performance Monitoring
        function startPerformanceMonitor() {
            if (performanceMonitor) {
                log('Performance monitor already running', 'warning');
                return;
            }
            
            log('Starting performance monitor...', 'info');
            
            performanceMonitor = setInterval(async () => {
                try {
                    const { particleSystem } = await getApp();
                    
                    // Update FPS
                    const fps = particleSystem.avgFrameTime ? 
                        Math.round(1000 / particleSystem.avgFrameTime) : '--';
                    document.getElementById('fps-display').textContent = fps;
                    
                    // Update particle count
                    document.getElementById('particle-count').textContent = particleSystem.particles.length;
                    
                    // Update memory usage (approximate)
                    if (performance.memory) {
                        const memory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                        document.getElementById('memory-usage').textContent = `${memory}MB`;
                    }
                    
                    // Update render time
                    const renderTime = particleSystem.avgFrameTime ? 
                        `${particleSystem.avgFrameTime.toFixed(1)}ms` : '--';
                    document.getElementById('render-time').textContent = renderTime;
                    
                } catch (error) {
                    if (verboseLogging) {
                        log(`Performance monitor error: ${error.message}`, 'error');
                    }
                }
            }, 1000);
        }
        
        function stopPerformanceMonitor() {
            if (performanceMonitor) {
                clearInterval(performanceMonitor);
                performanceMonitor = null;
                log('Performance monitor stopped', 'info');
            }
        }
        
        async function testHighParticleCount() {
            log('Testing high particle count performance...', 'info');
            
            try {
                const { doc, particleSystem } = await getApp();
                
                const originalCount = particleSystem.numParticles;
                log(`Original particle count: ${originalCount}`, 'info');
                
                // Test with 1000 particles
                const testCount = 1000;
                particleSystem.setNumParticles(testCount);
                
                log(`Set particle count to ${testCount}`, 'info');
                
                // Monitor for 5 seconds
                let samples = 0;
                let totalFPS = 0;
                
                const testInterval = setInterval(() => {
                    if (particleSystem.avgFrameTime) {
                        const fps = 1000 / particleSystem.avgFrameTime;
                        totalFPS += fps;
                        samples++;
                    }
                }, 500);
                
                setTimeout(() => {
                    clearInterval(testInterval);
                    
                    if (samples > 0) {
                        const avgFPS = Math.round(totalFPS / samples);
                        log(`Average FPS with ${testCount} particles: ${avgFPS}`, 
                            avgFPS > 30 ? 'success' : avgFPS > 15 ? 'warning' : 'error');
                    }
                    
                    // Restore original count
                    particleSystem.setNumParticles(originalCount);
                    log(`Restored particle count to ${originalCount}`, 'info');
                }, 5000);
                
            } catch (error) {
                log(`High particle count test failed: ${error.message}`, 'error');
            }
        }
        
        // Storage & Memory
        async function checkStorage() {
            log('Checking storage systems...', 'info');
            
            try {
                // Check localStorage
                const localStorageWorks = typeof localStorage !== 'undefined';
                log(`localStorage: ${localStorageWorks ? 'Available' : 'Not available'}`, 
                    localStorageWorks ? 'success' : 'error');
                
                // Check IndexedDB
                const indexedDBWorks = typeof indexedDB !== 'undefined';
                log(`IndexedDB: ${indexedDBWorks ? 'Available' : 'Not available'}`, 
                    indexedDBWorks ? 'success' : 'error');
                
                // Check preset manager
                const { win } = await getApp();
                if (win.presetManager) {
                    log('‚úì Preset manager: Available', 'success');
                    
                    const presets = await win.presetManager.getAllPresets();
                    log(`Stored presets: ${Object.keys(presets).length}`, 'info');
                } else {
                    log('‚úó Preset manager: Not available', 'error');
                }
                
            } catch (error) {
                log(`Storage check failed: ${error.message}`, 'error');
            }
        }

        async function deleteAllPresets() {
            log('üóëÔ∏è Starting complete preset deletion...', 'warning');
            
            if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL presets and clear all storage. This cannot be undone. Continue?')) {
                log('Preset deletion cancelled by user', 'info');
                return;
            }
            
            try {
                const { win } = await getApp();
                
                // Get preset manager and storage
                const presetManager = win.presetManager;
                const storage = (win.PresetStorage ? new win.PresetStorage.constructor() : null) || presetManager?.storage;
                
                if (!presetManager && !storage) {
                    log('‚úó No preset manager or storage found', 'error');
                    return;
                }
                
                // Get all stored presets via storage directly
                let presets = {};
                let deletedCount = 0;
                
                // Try to get presets from storage
                if (storage && storage.getAllPresets) {
                    try {
                        presets = await storage.getAllPresets();
                        log(`Found ${Object.keys(presets).length} presets in storage`, 'info');
                    } catch (error) {
                        log(`Could not get presets from storage: ${error.message}`, 'warning');
                    }
                }
                
                // Also try preset manager
                if (presetManager && presetManager.getAllPresets) {
                    try {
                        const managerPresets = await presetManager.getAllPresets();
                        const managerKeys = Array.isArray(managerPresets) ? 
                            managerPresets.map(p => p.key) : 
                            Object.keys(managerPresets);
                        log(`Found ${managerKeys.length} presets in manager`, 'info');
                        
                        // Merge preset keys
                        managerKeys.forEach(key => {
                            if (key && key !== 'undefined') {
                                presets[key] = { key };
                            }
                        });
                    } catch (error) {
                        log(`Could not get presets from manager: ${error.message}`, 'warning');
                    }
                }
                
                // Handle case where presets might be an array or object
                let presetList = [];
                if (Array.isArray(presets)) {
                    presetList = presets;
                } else if (typeof presets === 'object' && presets !== null) {
                    presetList = Object.values(presets);
                }
                
                log(`Processing ${presetList.length} presets for deletion...`, 'info');
                
                // Delete ALL presets via both manager and storage
                for (const preset of presetList) {
                    if (preset && preset.key) {
                        try {
                            // Delete via preset manager
                            if (presetManager && presetManager.deletePreset) {
                                await presetManager.deletePreset(preset.key);
                            }
                            
                            // Delete via storage directly
                            if (storage && storage.deletePreset) {
                                await storage.deletePreset(preset.key);
                            }
                            
                            deletedCount++;
                            log(`Deleted preset: ${preset.key}`, 'success');
                        } catch (error) {
                            log(`Failed to delete preset ${preset.key}: ${error.message}`, 'warning');
                        }
                    }
                }
                
                // Clear ALL localStorage entries related to presets
                const localStorageKeys = Object.keys(localStorage);
                const presetKeys = localStorageKeys.filter(key => 
                    key.startsWith('preset_') || 
                    key === 'userPresets' || 
                    key === 'lastSelectedPreset' || 
                    key === 'lastScene' ||
                    key === 'particleLifePresets' ||
                    key === 'particleLifePresetsMeta'
                );
                
                presetKeys.forEach(key => {
                    localStorage.removeItem(key);
                    log(`Removed from localStorage: ${key}`, 'info');
                });
                
                // Clear IndexedDB completely
                try {
                    const deleteRequest = indexedDB.deleteDatabase('ParticleLifeDB');
                    deleteRequest.onsuccess = () => {
                        log('‚úì IndexedDB deleted successfully', 'success');
                    };
                    deleteRequest.onerror = () => {
                        log('‚úó Failed to delete IndexedDB', 'error');
                    };
                } catch (error) {
                    log(`Error deleting IndexedDB: ${error.message}`, 'warning');
                }
                
                // Update UI to reflect changes
                if (win.mainUI && win.mainUI.updatePresetSelector) {
                    win.mainUI.updatePresetSelector();
                    log('‚úì Updated main UI preset selector', 'success');
                }
                
                log(`‚úÖ Cleanup complete! Deleted ${deletedCount} presets and cleared all storage.`, 'success');
                log('üîÑ Refresh the main app to see the clean state.', 'info');
                
            } catch (error) {
                log(`‚ùå Preset deletion failed: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }

        async function clearStorage() {
            log('Clearing general storage...', 'warning');
            
            try {
                // Clear general localStorage items (but not presets)
                const keysToRemove = ['lastScene', 'lastSelectedPreset'];
                keysToRemove.forEach(key => {
                    if (localStorage.getItem(key)) {
                        localStorage.removeItem(key);
                        log(`Removed ${key} from localStorage`, 'info');
                    }
                });
                
                log('‚úì General storage cleared', 'success');
                
            } catch (error) {
                log(`Storage clear failed: ${error.message}`, 'error');
            }
        }
        
        // Initialize
        window.addEventListener('load', () => {
            log('Debug tools loaded', 'success');
            
            // Auto-start some basic checks
            setTimeout(() => {
                checkBasics();
                updateSpeciesStatus();
            }, 2000);
        });
        
        async function testRandomizeValues() {
            log('üé≤ Testing randomize values functionality...', 'info');
            
            try {
                const { doc, particleSystem, mainUI } = await getApp();
                
                // Check if button exists
                const button = doc.getElementById('randomize-values-btn');
                if (!button) {
                    log('‚úó Randomize values button not found', 'error');
                    return;
                }
                log('‚úì Randomize values button found', 'success');
                
                // Check if method exists
                if (typeof mainUI.randomizeValues !== 'function') {
                    log('‚úó randomizeValues method not found on MainUI', 'error');
                    return;
                }
                log('‚úì randomizeValues method exists', 'success');
                
                // Capture original state
                const originalState = {
                    particleSize: particleSystem.particleSize,
                    numSpecies: particleSystem.numSpecies,
                    forceFactor: particleSystem.forceFactor,
                    friction: particleSystem.friction,
                    wallDamping: particleSystem.wallDamping,
                    trailEnabled: particleSystem.trailEnabled,
                    blur: particleSystem.blur,
                    particleCount: particleSystem.particles.length
                };
                
                log(`Original state: ${Object.entries(originalState).map(([k,v]) => `${k}=${v}`).join(', ')}`, 'info');
                
                // Test randomization scenarios
                const scenarios = ['swarms', 'crystals', 'plasma', 'organic', 'chaos', 'minimal', 'dreamscape'];
                let successfulRandomizations = 0;
                
                for (let i = 0; i < 3; i++) {
                    log(`Testing randomization ${i + 1}/3...`, 'info');
                    
                    // Click the button
                    button.click();
                    
                    // Wait for randomization to complete
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Check if values changed
                    const newState = {
                        particleSize: particleSystem.particleSize,
                        numSpecies: particleSystem.numSpecies,
                        forceFactor: particleSystem.forceFactor,
                        friction: particleSystem.friction,
                        wallDamping: particleSystem.wallDamping,
                        trailEnabled: particleSystem.trailEnabled,
                        blur: particleSystem.blur,
                        particleCount: particleSystem.particles.length
                    };
                    
                    // Count how many parameters changed
                    let changedParams = 0;
                    for (const [key, value] of Object.entries(newState)) {
                        if (Math.abs(originalState[key] - value) > 0.001 || originalState[key] !== value) {
                            changedParams++;
                        }
                    }
                    
                    if (changedParams > 0) {
                        log(`‚úì Randomization ${i + 1}: ${changedParams} parameters changed`, 'success');
                        successfulRandomizations++;
                        
                        // Log specific changes
                        log(`New state: Size=${newState.particleSize.toFixed(1)}, Species=${newState.numSpecies}, Force=${newState.forceFactor.toFixed(2)}`, 'info');
                        
                        // Test UI sync
                        const sizeDisplay = doc.getElementById('particle-size-value');
                        if (sizeDisplay && Math.abs(parseFloat(sizeDisplay.textContent) - newState.particleSize) < 0.1) {
                            log('‚úì UI display synchronized with particle system', 'success');
                        } else {
                            log(`‚úó UI display not synchronized: display=${sizeDisplay?.textContent}, system=${newState.particleSize}`, 'warning');
                        }
                    } else {
                        log(`‚úó Randomization ${i + 1}: No parameters changed`, 'warning');
                    }
                    
                    // Update original state for next comparison
                    Object.assign(originalState, newState);
                    
                    // Wait before next test
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                // Test keyboard shortcut (V key)
                log('Testing keyboard shortcut (V key)...', 'info');
                const keyEvent = new KeyboardEvent('keydown', { key: 'v', bubbles: true });
                doc.dispatchEvent(keyEvent);
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Check color randomization
                log('Testing color randomization...', 'info');
                const colors = particleSystem.species.map(s => s.color);
                const uniqueColors = new Set(colors.map(c => `${c.r},${c.g},${c.b}`));
                
                if (uniqueColors.size >= Math.min(particleSystem.numSpecies, 3)) {
                    log(`‚úì Color diversity: ${uniqueColors.size} unique colors for ${particleSystem.numSpecies} species`, 'success');
                } else {
                    log(`‚úó Low color diversity: ${uniqueColors.size} unique colors for ${particleSystem.numSpecies} species`, 'warning');
                }
                
                // Test glow effects
                log('Testing glow effects...', 'info');
                const glowingSpecies = particleSystem.speciesGlowIntensity.filter(intensity => intensity > 0).length;
                log(`Glowing species: ${glowingSpecies}/${particleSystem.numSpecies}`, 'info');
                
                // Summary
                if (successfulRandomizations >= 2) {
                    log(`‚úÖ Randomize values test PASSED: ${successfulRandomizations}/3 randomizations successful`, 'success');
                } else {
                    log(`‚ùå Randomize values test FAILED: Only ${successfulRandomizations}/3 randomizations successful`, 'error');
                }
                
            } catch (error) {
                log(`‚úó Randomize values test failed: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }
        
        // Expose functions to global scope for button onclick handlers
        window.checkBasics = checkBasics;
        window.checkElements = checkElements;
        window.checkEventHandlers = checkEventHandlers;
        window.checkDuplicates = checkDuplicates;
        window.testSimpleChange = testSimpleChange;
        window.debugSpeciesCount = debugSpeciesCount;
        window.debugSpeciesColors = debugSpeciesColors;
        window.debugSpeciesGlow = debugSpeciesGlow;
        window.testSpeciesSync = testSpeciesSync;
        window.testGlowPerformance = testGlowPerformance;
        window.checkSliderStates = checkSliderStates;
        window.testSliderUpdates = testSliderUpdates;
        window.debugModalSync = debugModalSync;
        window.checkCanvasZIndex = checkCanvasZIndex;
        window.testRandomizeValues = testRandomizeValues;
        window.startPerformanceMonitor = startPerformanceMonitor;
        window.stopPerformanceMonitor = stopPerformanceMonitor;
        window.testHighParticleCount = testHighParticleCount;
        window.testGlowScaling = testGlowScaling;
        window.profileGlowImpact = profileGlowImpact;
        window.checkStorage = checkStorage;
        window.testPresetSave = testPresetSave;
        window.clearStorage = clearStorage;
        window.deleteAllPresets = deleteAllPresets;
        window.checkMemoryLeaks = checkMemoryLeaks;
        window.runAllValidations = runAllValidations;
        window.validateTrailRendering = validateTrailRendering;
        window.validateColorPickerModal = validateColorPickerModal;
        window.validateSpeciesCountFix = validateSpeciesCountFix;
        window.validateUIStateManager = validateUIStateManager;
        window.validateDOMHelpers = validateDOMHelpers;
        window.clearLogs = clearLogs;
        window.exportLogs = exportLogs;
        window.toggleVerboseLogging = toggleVerboseLogging;
        window.fixSliderSync = fixSliderSync;
        window.analyzeFirebaseDatabase = analyzeFirebaseDatabase;
        window.listFirebasePresets = listFirebasePresets;
        window.cleanupFirebaseInvalidPresets = cleanupFirebaseInvalidPresets;
        window.removeFirebaseDuplicates = removeFirebaseDuplicates;
        window.migrateBuiltInPresets = migrateBuiltInPresets;
        window.deleteAllFirebaseTestPresets = deleteAllFirebaseTestPresets;
        
        // Export logs function
        function exportLogs() {
            const logText = Array.from(logs.children)
                .map(entry => entry.textContent)
                .join('\\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug-logs-${new Date().toISOString().slice(0, 19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('Logs exported', 'success');
        }
        
        function toggleVerboseLogging() {
            verboseLogging = !verboseLogging;
            log(`Verbose logging: ${verboseLogging ? 'ON' : 'OFF'}`, 'info');
        }
        
        async function fixSliderSync() {
            log('üîß Fixing slider synchronization...', 'info');
            
            try {
                const { win, doc, particleSystem } = await getApp();
                
                if (!win.mainUI || typeof win.mainUI.updateUIFromParticleSystem !== 'function') {
                    log('‚úó MainUI updateUIFromParticleSystem method not found', 'error');
                    return;
                }
                
                // Force update UI from particle system
                win.mainUI.updateUIFromParticleSystem();
                
                // Wait a moment for updates to take effect
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Verify the fix worked
                const slider = doc.getElementById('particles-per-species');
                const display = doc.getElementById('particles-per-species-value');
                
                if (slider && display) {
                    const sliderValue = parseFloat(slider.value);
                    const displayValue = parseFloat(display.textContent);
                    const systemValue = particleSystem.particlesPerSpecies;
                    
                    log(`After sync: slider=${sliderValue}, display=${displayValue}, system=${systemValue}`, 'info');
                    
                    if (Math.abs(sliderValue - systemValue) < 0.01 && Math.abs(displayValue - systemValue) < 0.01) {
                        log('‚úÖ Slider sync fixed successfully', 'success');
                    } else {
                        log('‚ö†Ô∏è Sync issue may persist - check for deeper problems', 'warning');
                    }
                } else {
                    log('‚úó Could not find slider or display elements', 'error');
                }
                
            } catch (error) {
                log(`‚úó Fix slider sync failed: ${error.message}`, 'error');
            }
        }
        
        // === CONSOLIDATED VALIDATION FUNCTIONS ===
        // Merged from test-dashboard.html and validate-fixes.html as per MASTER_DEVELOPMENT_PLAN.md
        
        async function validateTrailRendering() {
            log('üß™ Validating trail rendering fix (Issue #14)...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                
                if (typeof particleSystem.applyTrailDecay === 'function') {
                    log('‚úì applyTrailDecay method exists', 'success');
                    
                    // Test trail toggle
                    const originalTrail = particleSystem.trailEnabled;
                    particleSystem.trailEnabled = true;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    particleSystem.trailEnabled = false;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Restore original state
                    particleSystem.trailEnabled = originalTrail;
                    
                    log('‚úì Trail rendering validation passed', 'success');
                } else {
                    log('‚úó applyTrailDecay method not found', 'error');
                }
            } catch (error) {
                log(`‚úó Trail rendering validation failed: ${error.message}`, 'error');
            }
        }
        
        async function validateColorPickerModal() {
            log('üé® Validating color picker modal fix (Issue #15)...', 'info');
            
            try {
                const { win, doc } = await getApp();
                
                // Check for preset modal
                const configBtn = doc.getElementById('config-button');
                if (!configBtn) {
                    log('‚úó Configuration button not found', 'error');
                    return;
                }
                
                log('‚úì Configuration button found', 'success');
                
                // Simulate opening modal
                configBtn.click();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const modal = doc.querySelector('.preset-modal');
                if (modal && modal.style.display !== 'none') {
                    log('‚úì Preset modal opens correctly', 'success');
                    
                    // Close modal
                    const closeBtn = modal.querySelector('.close');
                    if (closeBtn) {
                        closeBtn.click();
                        log('‚úì Color picker modal validation passed', 'success');
                    }
                } else {
                    log('‚úó Preset modal not visible or not found', 'warning');
                }
            } catch (error) {
                log(`‚úó Color picker modal validation failed: ${error.message}`, 'error');
            }
        }
        
        async function validateUIStateManager() {
            log('‚öôÔ∏è Validating UI State Manager...', 'info');
            
            try {
                const { win } = await getApp();
                
                if (win.UIStateManager) {
                    log('‚úì UIStateManager class found', 'success');
                } else if (win.uiStateManager) {
                    log('‚úì UIStateManager instance found', 'success');
                } else {
                    log('‚úó UIStateManager not found', 'error');
                    return;
                }
                
                log('‚úì UI State Manager validation passed', 'success');
            } catch (error) {
                log(`‚úó UI State Manager validation failed: ${error.message}`, 'error');
            }
        }
        
        async function testCollapsibleScrolling() {
            log('üìú Testing collapsible section scrolling fix...', 'info');
            
            try {
                const { doc } = await getApp();
                const container = doc.querySelector('.main-ui-container');
                
                if (!container) {
                    log('‚úó Main UI container not found', 'error');
                    return;
                }
                
                // Get initial container state
                log(`Container dimensions: ${container.clientHeight}px (client) x ${container.scrollHeight}px (scroll)`, 'info');
                log(`Container scrollable: ${container.scrollHeight > container.clientHeight}`, 'info');
                
                // Find particles and forces sections
                const particlesSection = doc.querySelector('[data-section-id="particles"]');
                const forcesSection = doc.querySelector('[data-section-id="forces"]');
                
                if (!particlesSection || !forcesSection) {
                    log('‚úó Could not find particles or forces sections', 'error');
                    return;
                }
                
                // Open particles section
                const particlesHeader = particlesSection.querySelector('.collapsible-header');
                if (particlesHeader) {
                    // Check initial state
                    const wasOpen = particlesSection.classList.contains('open');
                    log(`Particles section was ${wasOpen ? 'open' : 'closed'}`, 'info');
                    
                    // If already open, close it first
                    if (wasOpen) {
                        log('Closing particles section first...', 'info');
                        particlesHeader.click();
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                    
                    // Now open it
                    log('Opening particles section...', 'info');
                    particlesHeader.click();
                    await new Promise(resolve => setTimeout(resolve, 800)); // Wait for animation
                    
                    // Check if it actually opened
                    const isOpen = particlesSection.classList.contains('open');
                    log(`Particles section is now ${isOpen ? 'open' : 'closed'}`, 'info');
                    
                    const particlesContent = particlesSection.querySelector('.collapsible-content');
                    const particlesHeight = particlesContent ? window.getComputedStyle(particlesContent).maxHeight : 'unknown';
                    log(`Particles section max-height: ${particlesHeight}`, 'info');
                    
                    // Also check the actual scrollHeight of the content
                    if (particlesContent) {
                        const inner = particlesContent.querySelector('.collapsible-content-inner');
                        if (inner) {
                            log(`Particles inner content scrollHeight: ${inner.scrollHeight}px`, 'info');
                        }
                    }
                    
                    // Check container scroll state after opening
                    log(`After opening particles - Container scrollable: ${container.scrollHeight > container.clientHeight}`, 'info');
                    log(`Container scroll height: ${container.scrollHeight}px, client height: ${container.clientHeight}px`, 'info');
                    
                    // Try to scroll to bottom to check if all controls are accessible
                    const originalScrollTop = container.scrollTop;
                    container.scrollTop = container.scrollHeight;
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const scrolled = container.scrollTop > originalScrollTop;
                    if (scrolled) {
                        log('‚úì Container can scroll after opening particles section', 'success');
                        
                        // Check if specific controls are visible
                        const collisionOffset = doc.querySelector('#collision-offset');
                        const breathToggle = doc.querySelector('#collision-offset-breath');
                        const breathControls = doc.querySelector('#breath-controls');
                        
                        if (collisionOffset) {
                            const rect = collisionOffset.getBoundingClientRect();
                            const inView = rect.top >= 0 && rect.bottom <= window.innerHeight;
                            log(`Collision Offset control ${inView ? '‚úì visible' : '‚úó not visible'} (top: ${rect.top}, bottom: ${rect.bottom})`, inView ? 'success' : 'error');
                        } else {
                            log('‚úó Collision Offset control not found', 'error');
                        }
                        
                        if (breathToggle) {
                            const rect = breathToggle.getBoundingClientRect();
                            const inView = rect.top >= 0 && rect.bottom <= window.innerHeight;
                            log(`Breath Toggle ${inView ? '‚úì visible' : '‚úó not visible'} (top: ${rect.top}, bottom: ${rect.bottom})`, inView ? 'success' : 'error');
                        } else {
                            log('‚úó Breath Toggle not found', 'error');
                        }
                        
                        if (breathControls) {
                            const rect = breathControls.getBoundingClientRect();
                            const inView = rect.top >= 0 && rect.bottom <= window.innerHeight;
                            log(`Breath Controls ${inView ? '‚úì visible' : '‚úó not visible'} (top: ${rect.top}, bottom: ${rect.bottom})`, inView ? 'success' : 'error');
                        } else {
                            log('‚úó Breath Controls not found', 'error');
                        }
                        
                        // Restore scroll position
                        container.scrollTop = originalScrollTop;
                    } else {
                        log('‚ö†Ô∏è Container did not scroll - may indicate the issue persists', 'warning');
                    }
                    
                    // Close particles section
                    particlesHeader.click();
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Test forces section too
                const forcesHeader = forcesSection.querySelector('.collapsible-header');
                if (forcesHeader) {
                    log('Opening forces section...', 'info');
                    forcesHeader.click();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const forcesContent = forcesSection.querySelector('.collapsible-content');
                    const forcesHeight = forcesContent ? window.getComputedStyle(forcesContent).maxHeight : 'unknown';
                    log(`Forces section max-height: ${forcesHeight}`, 'info');
                    
                    log(`After opening forces - Container scrollable: ${container.scrollHeight > container.clientHeight}`, 'info');
                    log(`Container scroll height: ${container.scrollHeight}px, client height: ${container.clientHeight}px`, 'info');
                    
                    // Close forces section
                    forcesHeader.click();
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                log('‚úÖ Collapsible scrolling test completed', 'success');
                
            } catch (error) {
                log(`‚úó Collapsible scrolling test failed: ${error.message}`, 'error');
            }
        }
        
        async function validateDOMHelpers() {
            log('üîß Validating DOM Helpers...', 'info');
            
            try {
                const { win } = await getApp();
                
                if (win.DOMHelpers && typeof win.DOMHelpers.safeAddEventListener === 'function') {
                    log('‚úì DOMHelpers loaded and functional', 'success');
                } else {
                    log('‚úó DOMHelpers not found or incomplete', 'error');
                    return;
                }
                
                log('‚úì DOM Helpers validation passed', 'success');
            } catch (error) {
                log(`‚úó DOM Helpers validation failed: ${error.message}`, 'error');
            }
        }
        
        async function validateSpeciesCountFix() {
            log('üß¨ Validating species count fix (Issue #16)...', 'info');
            
            try {
                const { particleSystem, doc } = await getApp();
                
                if (!particleSystem.setSpeciesCount) {
                    log('‚úó setSpeciesCount method not found', 'error');
                    return;
                }
                
                const originalCount = particleSystem.numSpecies;
                const testCount = originalCount === 5 ? 8 : 5;
                
                log(`Canvas dimensions: ${particleSystem.width} x ${particleSystem.height}`, 'info');
                log(`Spatial grid: ${particleSystem.gridWidth} x ${particleSystem.gridHeight} = ${particleSystem.spatialGrid?.length || 'undefined'} cells`, 'info');
                log(`Testing species count change: ${originalCount} ‚Üí ${testCount}`, 'info');
                
                // Capture console errors
                const originalConsoleError = console.error;
                const errors = [];
                console.error = (...args) => {
                    errors.push(args.join(' '));
                    originalConsoleError(...args);
                };
                
                const result = particleSystem.setSpeciesCount(testCount);
                
                // Restore console.error
                console.error = originalConsoleError;
                
                if (!result) {
                    log('‚úó setSpeciesCount returned false', 'error');
                    return;
                }
                
                if (errors.length > 0) {
                    log(`‚ö†Ô∏è Console errors during change: ${errors.join('; ')}`, 'warning');
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (particleSystem.numSpecies === testCount) {
                    log('‚úì Species count updated correctly', 'success');
                    
                    // Check particles are moving
                    const particle = particleSystem.particles[0];
                    const initialPos = { x: particle.x, y: particle.y };
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const finalPos = { x: particle.x, y: particle.y };
                    const moved = Math.abs(finalPos.x - initialPos.x) > 0.1 || Math.abs(finalPos.y - initialPos.y) > 0.1;
                    
                    if (moved) {
                        log('‚úì Particles moving correctly after species change', 'success');
                    } else {
                        log('‚úó Particles appear frozen after species change', 'error');
                    }
                    
                    // Check UI sync
                    const mainSlider = doc.querySelector('#species-count:not(.preset-modal #species-count)');
                    const mainDisplay = doc.querySelector('#species-count-value:not(.preset-modal #species-count-value)');
                    
                    if (mainSlider && parseInt(mainSlider.value) === testCount) {
                        log('‚úì Main UI slider synchronized', 'success');
                    } else {
                        log(`‚úó Main UI slider not synchronized: slider=${mainSlider?.value}, expected=${testCount}`, 'error');
                    }
                    
                    if (mainDisplay && parseInt(mainDisplay.textContent) === testCount) {
                        log('‚úì Main UI display synchronized', 'success');
                    } else {
                        log(`‚úó Main UI display not synchronized: display=${mainDisplay?.textContent}, expected=${testCount}`, 'error');
                    }
                    
                    // Restore original count
                    particleSystem.setSpeciesCount(originalCount);
                    log(`‚úì Species count validation completed`, 'success');
                } else {
                    log(`‚úó Species count not updated: expected ${testCount}, got ${particleSystem.numSpecies}`, 'error');
                }
            } catch (error) {
                log(`‚úó Species count validation failed: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }
        
        // Boundary Behavior Testing Functions
        async function testBoundaryBehavior() {
            log('üèõÔ∏è Testing boundary behavior system...', 'info');
            
            try {
                const ps = window.particleSystem;
                if (!ps) {
                    log('‚úó No particle system found', 'error');
                    return;
                }
                
                // Test both repulsive and wrap-around modes
                await testRepulsiveForce();
                await new Promise(resolve => setTimeout(resolve, 1000));
                await testWrapAroundMode();
                
                updateBoundaryStatus();
                log('‚úÖ Boundary behavior test completed', 'success');
                
            } catch (error) {
                log(`‚úó Boundary behavior test failed: ${error.message}`, 'error');
            }
        }
        
        async function testRepulsiveForce() {
            log('‚ö° Testing repulsive force effectiveness...', 'info');
            
            try {
                const ps = window.particleSystem;
                
                // Disable wrap-around and enable repulsive force
                ps.wrapAroundWalls = false;
                ps.repulsiveForce = 1.0; // Max strength
                
                // Create test particles near edges
                const testParticles = [];
                for (let i = 0; i < 10; i++) {
                    const particle = {
                        x: Math.random() * 30, // Near left edge
                        y: Math.random() * ps.height,
                        vx: 1.0, // Moving toward edge
                        vy: 0,
                        species: 0
                    };
                    testParticles.push(particle);
                    ps.particles.push(particle);
                }
                
                // Run simulation for a bit and check if particles are repelled
                const initialPositions = testParticles.map(p => ({ x: p.x, y: p.y }));
                
                // Simulate for 100ms
                for (let i = 0; i < 10; i++) {
                    ps.update(0.016);
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // Check if particles moved away from edge
                let repelledCount = 0;
                testParticles.forEach((p, idx) => {
                    if (p.x > initialPositions[idx].x + 5) { // Moved at least 5px away
                        repelledCount++;
                    }
                });
                
                // Clean up test particles
                testParticles.forEach(tp => {
                    const index = ps.particles.indexOf(tp);
                    if (index > -1) ps.particles.splice(index, 1);
                });
                
                const effectiveness = (repelledCount / testParticles.length) * 100;
                log(`üìä Repulsive force effectiveness: ${effectiveness.toFixed(1)}% (${repelledCount}/${testParticles.length})`, 
                    effectiveness > 70 ? 'success' : 'warning');
                
                return effectiveness > 70;
                
            } catch (error) {
                log(`‚úó Repulsive force test failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function testWrapAroundMode() {
            log('üîÑ Testing wrap-around mode smoothness...', 'info');
            
            try {
                const ps = window.particleSystem;
                
                // Enable wrap-around mode
                ps.wrapAroundWalls = true;
                ps.repulsiveForce = 0;
                
                // Create test particles at boundaries
                const testParticles = [];
                const testCases = [
                    { x: -5, y: ps.height / 2, vx: -2, vy: 0 }, // Past left edge
                    { x: ps.width + 5, y: ps.height / 2, vx: 2, vy: 0 }, // Past right edge
                    { x: ps.width / 2, y: -5, vx: 0, vy: -2 }, // Past top edge
                    { x: ps.width / 2, y: ps.height + 5, vx: 0, vy: 2 } // Past bottom edge
                ];
                
                testCases.forEach(testCase => {
                    const particle = { ...testCase, species: 0 };
                    testParticles.push(particle);
                    ps.particles.push(particle);
                });
                
                // Record initial out-of-bounds states
                const initialOOB = testParticles.map(p => ({
                    outOfBounds: p.x < 0 || p.x > ps.width || p.y < 0 || p.y > ps.height,
                    x: p.x, y: p.y
                }));
                
                // Simulate for one frame to test wrapping
                ps.update(0.016);
                
                // Check if particles are now in bounds
                let wrappedCorrectly = 0;
                testParticles.forEach((p, idx) => {
                    const nowInBounds = p.x >= 0 && p.x <= ps.width && p.y >= 0 && p.y <= ps.height;
                    if (initialOOB[idx].outOfBounds && nowInBounds) {
                        wrappedCorrectly++;
                    }
                });
                
                // Clean up test particles
                testParticles.forEach(tp => {
                    const index = ps.particles.indexOf(tp);
                    if (index > -1) ps.particles.splice(index, 1);
                });
                
                const wrappingSuccess = (wrappedCorrectly / testParticles.length) * 100;
                log(`üîÑ Wrap-around success rate: ${wrappingSuccess.toFixed(1)}% (${wrappedCorrectly}/${testParticles.length})`, 
                    wrappingSuccess > 80 ? 'success' : 'warning');
                
                return wrappingSuccess > 80;
                
            } catch (error) {
                log(`‚úó Wrap-around test failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function stressBoundarySystem() {
            log('üèãÔ∏è Stress testing boundary system with high particle count...', 'info');
            
            try {
                const ps = window.particleSystem;
                
                // Save original settings
                const originalCount = ps.particles.length;
                const originalRepulsive = ps.repulsiveForce;
                const originalWrap = ps.wrapAroundWalls;
                
                // Test with high particle count and maximum repulsion
                ps.repulsiveForce = 1.0;
                ps.wrapAroundWalls = false;
                
                // Add many particles near edges
                const stressParticles = [];
                for (let i = 0; i < 200; i++) {
                    const edge = Math.floor(Math.random() * 4);
                    let x, y, vx, vy;
                    
                    switch (edge) {
                        case 0: // Left edge
                            x = Math.random() * 50;
                            y = Math.random() * ps.height;
                            vx = Math.random() - 0.5;
                            vy = (Math.random() - 0.5) * 4;
                            break;
                        case 1: // Right edge
                            x = ps.width - Math.random() * 50;
                            y = Math.random() * ps.height;
                            vx = Math.random() - 0.5;
                            vy = (Math.random() - 0.5) * 4;
                            break;
                        case 2: // Top edge
                            x = Math.random() * ps.width;
                            y = Math.random() * 50;
                            vx = (Math.random() - 0.5) * 4;
                            vy = Math.random() - 0.5;
                            break;
                        case 3: // Bottom edge
                            x = Math.random() * ps.width;
                            y = ps.height - Math.random() * 50;
                            vx = (Math.random() - 0.5) * 4;
                            vy = Math.random() - 0.5;
                            break;
                    }
                    
                    const particle = { x, y, vx, vy, species: Math.floor(Math.random() * ps.numSpecies) };
                    stressParticles.push(particle);
                    ps.particles.push(particle);
                }
                
                // Monitor performance during stress test
                const startTime = performance.now();
                let frameCount = 0;
                
                for (let i = 0; i < 60; i++) { // 1 second at 60fps
                    ps.update(0.016);
                    frameCount++;
                    
                    if (i % 10 === 0) { // Update every 10 frames
                        updateBoundaryStatus();
                        await new Promise(resolve => setTimeout(resolve, 16));
                    }
                }
                
                const endTime = performance.now();
                const avgFrameTime = (endTime - startTime) / frameCount;
                const fps = 1000 / avgFrameTime;
                
                // Clean up stress test particles
                stressParticles.forEach(sp => {
                    const index = ps.particles.indexOf(sp);
                    if (index > -1) ps.particles.splice(index, 1);
                });
                
                // Restore original settings
                ps.repulsiveForce = originalRepulsive;
                ps.wrapAroundWalls = originalWrap;
                
                const performanceRating = fps > 30 ? 'Excellent' : fps > 20 ? 'Good' : fps > 10 ? 'Fair' : 'Poor';
                log(`üìä Stress test completed: ${fps.toFixed(1)} FPS (${performanceRating})`, 
                    fps > 30 ? 'success' : fps > 20 ? 'info' : 'warning');
                
                updateBoundaryStatus();
                
            } catch (error) {
                log(`‚úó Stress test failed: ${error.message}`, 'error');
            }
        }
        
        function updateBoundaryStatus() {
            try {
                const ps = window.particleSystem;
                if (!ps) return;
                
                // Update repulsive force value
                const repulsiveDisplay = document.getElementById('repulsive-value');
                if (repulsiveDisplay) {
                    repulsiveDisplay.textContent = ps.repulsiveForce ? ps.repulsiveForce.toFixed(2) : '0.00';
                }
                
                // Update wrap mode
                const wrapDisplay = document.getElementById('wrap-mode');
                if (wrapDisplay) {
                    wrapDisplay.textContent = ps.wrapAroundWalls ? 'ON' : 'OFF';
                }
                
                // Count particles near edges
                const edgeThreshold = 100;
                let edgeParticles = 0;
                ps.particles.forEach(p => {
                    if (p.x < edgeThreshold || p.x > ps.width - edgeThreshold ||
                        p.y < edgeThreshold || p.y > ps.height - edgeThreshold) {
                        edgeParticles++;
                    }
                });
                
                const edgeDisplay = document.getElementById('edge-particles');
                if (edgeDisplay) {
                    edgeDisplay.textContent = `${edgeParticles}/${ps.particles.length}`;
                }
                
                // Show boundary performance rating
                const perfDisplay = document.getElementById('boundary-perf');
                if (perfDisplay) {
                    const fps = ps.avgFrameTime ? (1000 / ps.avgFrameTime).toFixed(0) : '--';
                    perfDisplay.textContent = `${fps} FPS`;
                }
                
            } catch (error) {
                console.warn('Failed to update boundary status:', error);
            }
        }
        
        // Update boundary status periodically
        setInterval(updateBoundaryStatus, 1000);
        
        async function runAllValidations() {
            log('üöÄ Running all validation tests...', 'info');
            
            await validateTrailRendering();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await validateColorPickerModal(); 
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await validateUIStateManager();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await validateDOMHelpers();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await validateSpeciesCountFix();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testUndoSystem();
            
            log('üéØ All validations completed', 'info');
        }
        
        async function testUndoSystem() {
            log('üîÑ Testing Undo System (Ctrl+Z)...', 'info');
            
            try {
                const { doc, particleSystem, mainUI, undoManager } = await getApp();
                
                if (!undoManager) {
                    log('‚úó UndoManager not found - check if feature is properly integrated', 'error');
                    return;
                }
                
                log(`‚úì UndoManager found with ${undoManager.getUndoCount()} operations in history`, 'success');
                
                // Test 1: Randomize Values and Undo
                log('Testing randomize values + undo...', 'info');
                const originalParticleCount = particleSystem.particlesPerSpecies;
                const originalSpeciesCount = particleSystem.numSpecies;
                
                // Capture initial state for comparison
                const initialState = particleSystem.exportPreset();
                
                // Perform destructive operation: randomize values
                mainUI.randomizeValues();
                await new Promise(resolve => setTimeout(resolve, 100)); // Let state settle
                
                const afterRandomizeState = particleSystem.exportPreset();
                const changedValues = [];
                
                if (afterRandomizeState.particlesPerSpecies !== initialState.particlesPerSpecies) {
                    changedValues.push('particlesPerSpecies');
                }
                if (afterRandomizeState.numSpecies !== initialState.numSpecies) {
                    changedValues.push('numSpecies');
                }
                if (JSON.stringify(afterRandomizeState.socialForce) !== JSON.stringify(initialState.socialForce)) {
                    changedValues.push('socialForce');
                }
                
                log(`Values changed after randomization: ${changedValues.join(', ')}`, 'info');
                
                // Test undo
                const canUndo = undoManager.canUndo();
                if (!canUndo) {
                    log('‚úó Cannot undo - no operations in undo stack', 'error');
                    return;
                }
                
                const lastOp = undoManager.getLastOperation();
                log(`Last operation: ${lastOp.type} - ${lastOp.description}`, 'info');
                
                // Perform undo
                const undoSuccess = undoManager.undo();
                if (!undoSuccess) {
                    log('‚úó Undo operation failed', 'error');
                    return;
                }
                
                await new Promise(resolve => setTimeout(resolve, 100)); // Let state settle
                
                // Check if state was restored
                const afterUndoState = particleSystem.exportPreset();
                
                let restored = true;
                const restoredValues = [];
                
                if (Math.abs(afterUndoState.particlesPerSpecies - initialState.particlesPerSpecies) < 0.01) {
                    restoredValues.push('particlesPerSpecies');
                } else {
                    restored = false;
                }
                
                if (afterUndoState.numSpecies === initialState.numSpecies) {
                    restoredValues.push('numSpecies');
                } else {
                    restored = false;
                }
                
                if (JSON.stringify(afterUndoState.socialForce) === JSON.stringify(initialState.socialForce)) {
                    restoredValues.push('socialForce');
                } else {
                    restored = false;
                }
                
                if (restored) {
                    log(`‚úì Undo successful - restored: ${restoredValues.join(', ')}`, 'success');
                } else {
                    log(`‚úó Undo incomplete - only restored: ${restoredValues.join(', ')}`, 'warning');
                }
                
                // Test 2: Force pattern change and undo
                log('Testing force pattern change + undo...', 'info');
                
                const forcePatternSelector = doc.getElementById('force-pattern-selector');
                if (forcePatternSelector) {
                    const originalPattern = forcePatternSelector.value;
                    const patterns = Array.from(forcePatternSelector.options).map(opt => opt.value);
                    const newPattern = patterns.find(p => p !== originalPattern) || patterns[1];
                    
                    // Change pattern
                    forcePatternSelector.value = newPattern;
                    forcePatternSelector.dispatchEvent(new Event('change'));
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Undo
                    if (undoManager.canUndo()) {
                        undoManager.undo();
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        if (forcePatternSelector.value === originalPattern) {
                            log('‚úì Force pattern undo successful', 'success');
                        } else {
                            log(`‚úó Force pattern not restored: expected ${originalPattern}, got ${forcePatternSelector.value}`, 'warning');
                        }
                    } else {
                        log('‚úó No undo available for force pattern change', 'warning');
                    }
                } else {
                    log('‚ö†Ô∏è Force pattern selector not found - skipping test', 'warning');
                }
                
                // Test 3: Keyboard shortcut
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const shortcutName = isMac ? 'Cmd+Z' : 'Ctrl+Z';
                log(`Testing ${shortcutName} keyboard shortcut...`, 'info');
                
                // Make another change
                mainUI.randomizeForces();
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Simulate platform-appropriate undo keypress
                const undoEvent = new KeyboardEvent('keydown', {
                    key: 'z',
                    ctrlKey: !isMac,
                    metaKey: isMac,
                    bubbles: true
                });
                
                doc.dispatchEvent(undoEvent);
                await new Promise(resolve => setTimeout(resolve, 100));
                
                log(`‚úì ${shortcutName} keyboard shortcut test completed`, 'success');
                
                // Summary
                log(`üìä Undo System Summary:`, 'info');
                log(`   - UndoManager initialized: ‚úì`, 'info');
                log(`   - Undo stack operations: ${undoManager.getUndoCount()}`, 'info');
                log(`   - Memory usage: ~${Math.round(undoManager.getMemoryUsage() / 1024)}KB`, 'info');
                log(`   - Supported operations: ${undoManager.supportedOperations.join(', ')}`, 'info');
                
                log('üéØ Undo system test completed', 'success');
                
            } catch (error) {
                log(`‚úó Undo system test failed: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }
        
        async function testSpeciesSync() {
            log('üîÑ Testing species synchronization...', 'info');
            
            try {
                const { doc, particleSystem, mainUI } = await getApp();
                
                // Test species count changes and UI sync
                const originalCount = particleSystem.numSpecies;
                log(`Original species count: ${originalCount}`, 'info');
                
                // Test increasing species count
                const testCount = Math.min(originalCount + 2, 10);
                log(`Testing species count change to ${testCount}...`, 'info');
                
                const result = particleSystem.setSpeciesCount(testCount);
                if (!result) {
                    log('‚úó setSpeciesCount returned false', 'error');
                    return;
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check particle system state
                const newCount = particleSystem.numSpecies;
                if (newCount !== testCount) {
                    log(`‚úó Species count mismatch: expected ${testCount}, got ${newCount}`, 'error');
                    return;
                }
                log(`‚úì Particle system species count: ${newCount}`, 'success');
                
                // Check UI synchronization
                const mainUISlider = doc.querySelector('#species-count:not(.preset-modal #species-count)');
                const mainUIDisplay = doc.querySelector('#species-count-value:not(.preset-modal #species-count-value)');
                
                if (mainUISlider && parseInt(mainUISlider.value) === testCount) {
                    log('‚úì Main UI slider synchronized', 'success');
                } else {
                    log(`‚úó Main UI slider not synchronized: ${mainUISlider?.value || 'not found'}`, 'warning');
                }
                
                if (mainUIDisplay && parseInt(mainUIDisplay.textContent) === testCount) {
                    log('‚úì Main UI display synchronized', 'success');
                } else {
                    log(`‚úó Main UI display not synchronized: ${mainUIDisplay?.textContent || 'not found'}`, 'warning');
                }
                
                // Check species array consistency
                if (particleSystem.species && particleSystem.species.length === testCount) {
                    log('‚úì Species array length correct', 'success');
                } else {
                    log(`‚úó Species array length incorrect: ${particleSystem.species?.length || 'no array'}`, 'error');
                }
                
                // Check particles are assigned to species
                const particleCount = particleSystem.particles.length;
                if (particleCount > 0) {
                    log(`‚úì Particles exist: ${particleCount} total`, 'success');
                } else {
                    log('‚úó No particles found', 'error');
                }
                
                // Restore original count
                particleSystem.setSpeciesCount(originalCount);
                await new Promise(resolve => setTimeout(resolve, 200));
                
                log('‚úÖ Species synchronization test complete', 'success');
                updateSpeciesStatus();
                
            } catch (error) {
                log(`‚úó Species sync test failed: ${error.message}`, 'error');
            }
        }
        
        // === UI STATE DEBUGGING FUNCTIONS ===
        
        async function checkSliderStates() {
            log('üéõÔ∏è Checking slider states...', 'info');
            
            try {
                const { doc, particleSystem } = await getApp();
                
                // Calculate actual particles per species (might differ from global setting)
                let actualParticlesPerSpecies = particleSystem.particlesPerSpecies;
                if (particleSystem.species && particleSystem.species.length > 0) {
                    // Check if any species has custom particle counts
                    const totalParticles = particleSystem.particles.length;
                    const avgParticlesPerSpecies = Math.round(totalParticles / particleSystem.numSpecies);
                    
                    // If there's a significant difference, use the actual average
                    if (Math.abs(avgParticlesPerSpecies - particleSystem.particlesPerSpecies) > 5) {
                        actualParticlesPerSpecies = avgParticlesPerSpecies;
                        log(`üìä Using actual average particles per species: ${avgParticlesPerSpecies} (global setting: ${particleSystem.particlesPerSpecies})`, 'info');
                    }
                }
                
                // Define sliders to check
                const sliders = [
                    { id: 'particle-size', systemValue: particleSystem.particleSize },
                    { id: 'species-count', systemValue: particleSystem.numSpecies },
                    { id: 'force-strength', systemValue: particleSystem.forceFactor },
                    { id: 'friction', systemValue: 1.0 - particleSystem.friction }, // UI shows inverted
                    { id: 'wall-bounce', systemValue: particleSystem.wallDamping },
                    { id: 'particles-per-species', systemValue: actualParticlesPerSpecies }
                ];
                
                let allSynced = true;
                
                for (const { id, systemValue } of sliders) {
                    // Find main UI slider (not in modal)
                    const slider = doc.querySelector(`#${id}:not(.preset-modal #${id})`);
                    const display = doc.querySelector(`#${id}-value:not(.preset-modal #${id}-value)`);
                    
                    if (slider) {
                        const sliderValue = parseFloat(slider.value);
                        const diff = Math.abs(sliderValue - systemValue);
                        
                        if (diff < 0.01) {
                            log(`‚úì ${id}: slider=${sliderValue}, system=${systemValue}`, 'success');
                        } else {
                            log(`‚úó ${id}: slider=${sliderValue}, system=${systemValue} (diff: ${diff.toFixed(3)})`, 'warning');
                            
                            // Special handling for particles-per-species to show more detail
                            if (id === 'particles-per-species') {
                                log(`  üìä Total particles: ${particleSystem.particles.length}`, 'info');
                                log(`  üìä Species count: ${particleSystem.numSpecies}`, 'info');
                                log(`  üìä Global particles per species: ${particleSystem.particlesPerSpecies}`, 'info');
                                log(`  üìä Actual average: ${Math.round(particleSystem.particles.length / particleSystem.numSpecies)}`, 'info');
                                
                                // Check individual species counts
                                if (particleSystem.species) {
                                    let hasCustomCounts = false;
                                    for (let i = 0; i < particleSystem.numSpecies; i++) {
                                        const species = particleSystem.species[i];
                                        if (species && species.particleCount && species.particleCount !== particleSystem.particlesPerSpecies) {
                                            log(`  üìä Species ${i}: ${species.particleCount} particles (custom)`, 'info');
                                            hasCustomCounts = true;
                                        }
                                    }
                                    if (!hasCustomCounts) {
                                        log(`  üìä All species use global particle count`, 'info');
                                    }
                                }
                            }
                            
                            allSynced = false;
                        }
                        
                        // Check display value
                        if (display) {
                            const displayValue = parseFloat(display.textContent);
                            if (Math.abs(displayValue - sliderValue) < 0.01) {
                                log(`  ‚úì Display synchronized: ${displayValue}`, 'success');
                            } else {
                                log(`  ‚úó Display not synchronized: ${displayValue}`, 'warning');
                            }
                        } else {
                            log(`  ! No display element found for ${id}`, 'info');
                        }
                    } else {
                        log(`‚úó Slider #${id} not found`, 'error');
                        allSynced = false;
                    }
                }
                
                if (allSynced) {
                    log('‚úÖ All sliders synchronized with particle system', 'success');
                } else {
                    log('‚ö†Ô∏è Some sliders are out of sync', 'warning');
                }
                
            } catch (error) {
                log(`‚úó Slider state check failed: ${error.message}`, 'error');
            }
        }
        
        async function testSliderUpdates() {
            log('üîÑ Testing slider updates...', 'info');
            
            try {
                const { doc, particleSystem } = await getApp();
                
                // Test particle size slider
                const sizeSlider = doc.querySelector('#particle-size:not(.preset-modal #particle-size)');
                if (sizeSlider) {
                    const originalValue = sizeSlider.value;
                    const testValue = originalValue == 10 ? 15 : 10;
                    
                    log(`Testing particle size change: ${originalValue} ‚Üí ${testValue}`, 'info');
                    
                    sizeSlider.value = testValue;
                    sizeSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    if (Math.abs(particleSystem.particleSize - testValue) < 0.1) {
                        log('‚úì Particle size update successful', 'success');
                    } else {
                        log(`‚úó Particle size update failed: expected ${testValue}, got ${particleSystem.particleSize}`, 'error');
                    }
                    
                    // Restore original value
                    sizeSlider.value = originalValue;
                    sizeSlider.dispatchEvent(new Event('input', { bubbles: true }));
                } else {
                    log('‚úó Particle size slider not found', 'error');
                }
                
                log('‚úÖ Slider update test complete', 'success');
                
            } catch (error) {
                log(`‚úó Slider update test failed: ${error.message}`, 'error');
            }
        }
        
        async function debugModalSync() {
            log('üîó Debugging modal synchronization...', 'info');
            
            try {
                const { doc, particleSystem, presetModal } = await getApp();
                
                // Test opening and closing modal
                log('Opening preset modal...', 'info');
                presetModal.open(null);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check if modal elements exist
                const modalSizeSlider = doc.querySelector('.preset-modal #particle-size');
                const mainSizeSlider = doc.querySelector('#particle-size:not(.preset-modal #particle-size)');
                
                if (modalSizeSlider && mainSizeSlider) {
                    const modalValue = parseFloat(modalSizeSlider.value);
                    const mainValue = parseFloat(mainSizeSlider.value);
                    const systemValue = particleSystem.particleSize;
                    
                    log(`Modal slider: ${modalValue}`, 'info');
                    log(`Main slider: ${mainValue}`, 'info');
                    log(`System value: ${systemValue}`, 'info');
                    
                    if (Math.abs(modalValue - systemValue) < 0.1) {
                        log('‚úì Modal synchronized with system', 'success');
                    } else {
                        log('‚úó Modal not synchronized with system', 'warning');
                    }
                } else {
                    log('‚úó Modal or main sliders not found', 'error');
                }
                
                // Close modal
                presetModal.close();
                
                log('‚úÖ Modal sync debug complete', 'success');
                
            } catch (error) {
                log(`‚úó Modal sync debug failed: ${error.message}`, 'error');
            }
        }
        
        async function checkCanvasZIndex() {
            log('üé® Checking canvas z-index...', 'info');
            
            try {
                const { doc } = await getApp();
                
                const canvas = doc.getElementById('canvas');
                const floatingUI = doc.querySelector('.floating-ui');
                
                if (canvas) {
                    const canvasStyle = window.getComputedStyle(canvas);
                    const canvasZIndex = canvasStyle.zIndex;
                    log(`Canvas z-index: ${canvasZIndex}`, 'info');
                } else {
                    log('‚úó Canvas not found', 'error');
                }
                
                if (floatingUI) {
                    const uiStyle = window.getComputedStyle(floatingUI);
                    const uiZIndex = uiStyle.zIndex;
                    log(`Floating UI z-index: ${uiZIndex}`, 'info');
                    
                    if (parseInt(uiZIndex) > parseInt(canvasStyle?.zIndex || 0)) {
                        log('‚úì UI is above canvas', 'success');
                    } else {
                        log('‚úó UI may be behind canvas', 'warning');
                    }
                } else {
                    log('‚úó Floating UI not found', 'error');
                }
                
                log('‚úÖ Canvas z-index check complete', 'success');
                
            } catch (error) {
                log(`‚úó Canvas z-index check failed: ${error.message}`, 'error');
            }
        }
        
        // === GLOW PERFORMANCE TESTING FUNCTIONS ===
        // Enhanced testing for Issue #12: Glow Effect Performance Optimization
        
        async function testGlowPerformance() {
            log('üåü Testing glow performance (Issue #12)...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                const originalGlowSettings = [];
                
                // Save original glow settings for all species
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    originalGlowSettings[i] = particleSystem.getSpeciesGlow(i);
                }
                
                // Test scenarios: no glow, medium glow, high glow
                const scenarios = [
                    { name: 'No Glow', intensity: 0 },
                    { name: 'Medium Glow (0.5)', intensity: 0.5 },
                    { name: 'High Glow (1.0)', intensity: 1.0 }
                ];
                
                const results = [];
                
                for (const scenario of scenarios) {
                    log(`Testing scenario: ${scenario.name}`, 'info');
                    
                    // Set glow for all species
                    for (let i = 0; i < particleSystem.numSpecies; i++) {
                        particleSystem.setSpeciesGlow(i, { 
                            intensity: scenario.intensity,
                            size: 1.5 
                        });
                    }
                    
                    // Wait for system to stabilize
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Measure performance for 3 seconds
                    let samples = 0;
                    let totalFPS = 0;
                    let minFPS = Infinity;
                    let maxFPS = 0;
                    
                    const testInterval = setInterval(() => {
                        if (particleSystem.avgFrameTime) {
                            const fps = 1000 / particleSystem.avgFrameTime;
                            totalFPS += fps;
                            minFPS = Math.min(minFPS, fps);
                            maxFPS = Math.max(maxFPS, fps);
                            samples++;
                        }
                    }, 200);
                    
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    clearInterval(testInterval);
                    
                    if (samples > 0) {
                        const avgFPS = Math.round(totalFPS / samples);
                        results.push({
                            scenario: scenario.name,
                            avgFPS,
                            minFPS: Math.round(minFPS),
                            maxFPS: Math.round(maxFPS)
                        });
                        
                        log(`${scenario.name}: Avg FPS ${avgFPS} (${Math.round(minFPS)}-${Math.round(maxFPS)})`, 
                            avgFPS > 45 ? 'success' : avgFPS > 30 ? 'warning' : 'error');
                    }
                }
                
                // Restore original settings
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    particleSystem.setSpeciesGlow(i, originalGlowSettings[i]);
                }
                
                // Calculate performance impact
                if (results.length >= 2) {
                    const noGlowFPS = results[0].avgFPS;
                    const highGlowFPS = results[results.length - 1].avgFPS;
                    const impact = Math.round(((noGlowFPS - highGlowFPS) / noGlowFPS) * 100);
                    
                    log(`üìä Glow Impact: ${impact}% FPS reduction with high glow`, 
                        impact < 15 ? 'success' : impact < 30 ? 'warning' : 'error');
                }
                
                log('‚úì Glow performance test completed', 'success');
                
            } catch (error) {
                log(`‚úó Glow performance test failed: ${error.message}`, 'error');
            }
        }
        
        async function testGlowScaling() {
            log('üìà Testing glow scaling performance...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                const originalCount = particleSystem.numParticles;
                const originalGlowSettings = [];
                
                // Save original settings
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    originalGlowSettings[i] = particleSystem.getSpeciesGlow(i);
                }
                
                // Enable medium glow on all species
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    particleSystem.setSpeciesGlow(i, { intensity: 0.7, size: 1.5 });
                }
                
                const particleCounts = [200, 500, 1000, 1500];
                const results = [];
                
                for (const count of particleCounts) {
                    log(`Testing ${count} particles with glow...`, 'info');
                    
                    particleSystem.setNumParticles(count);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Measure for 2 seconds
                    let samples = 0;
                    let totalFPS = 0;
                    
                    const testInterval = setInterval(() => {
                        if (particleSystem.avgFrameTime) {
                            const fps = 1000 / particleSystem.avgFrameTime;
                            totalFPS += fps;
                            samples++;
                        }
                    }, 200);
                    
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    clearInterval(testInterval);
                    
                    if (samples > 0) {
                        const avgFPS = Math.round(totalFPS / samples);
                        results.push({ particles: count, fps: avgFPS });
                        
                        log(`${count} particles: ${avgFPS} FPS`, 
                            avgFPS > 30 ? 'success' : avgFPS > 15 ? 'warning' : 'error');
                    }
                }
                
                // Restore original settings
                particleSystem.setNumParticles(originalCount);
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    particleSystem.setSpeciesGlow(i, originalGlowSettings[i]);
                }
                
                // Calculate scaling efficiency
                if (results.length >= 2) {
                    const fps200 = results[0].fps;
                    const fps1000 = results.find(r => r.particles === 1000)?.fps;
                    
                    if (fps1000) {
                        const efficiency = (fps1000 / fps200) / (1000 / 200);
                        log(`üìä Glow scaling efficiency: ${Math.round(efficiency * 100)}%`, 
                            efficiency > 0.6 ? 'success' : efficiency > 0.4 ? 'warning' : 'error');
                    }
                }
                
                log('‚úì Glow scaling test completed', 'success');
                
            } catch (error) {
                log(`‚úó Glow scaling test failed: ${error.message}`, 'error');
            }
        }
        
        async function profileGlowImpact() {
            log('üîç Profiling glow rendering impact...', 'info');
            
            try {
                const { particleSystem } = await getApp();
                const originalSettings = [];
                
                // Save original settings
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    originalSettings[i] = particleSystem.getSpeciesGlow(i);
                }
                
                // Test different numbers of glowing species
                const glowTests = [
                    { name: 'No species with glow', glowSpecies: 0 },
                    { name: '1 species with glow', glowSpecies: 1 },
                    { name: '3 species with glow', glowSpecies: 3 },
                    { name: 'All species with glow', glowSpecies: particleSystem.numSpecies }
                ];
                
                for (const test of glowTests) {
                    log(`Testing: ${test.name}`, 'info');
                    
                    // Reset all glow
                    particleSystem.clearAllSpeciesGlow();
                    
                    // Set glow for specified number of species
                    for (let i = 0; i < test.glowSpecies; i++) {
                        particleSystem.setSpeciesGlow(i, { intensity: 0.8, size: 2.0 });
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Measure performance
                    let samples = 0;
                    let totalFPS = 0;
                    let renderTimeSum = 0;
                    
                    const testInterval = setInterval(() => {
                        if (particleSystem.avgFrameTime) {
                            const fps = 1000 / particleSystem.avgFrameTime;
                            totalFPS += fps;
                            renderTimeSum += particleSystem.avgFrameTime;
                            samples++;
                        }
                    }, 200);
                    
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    clearInterval(testInterval);
                    
                    if (samples > 0) {
                        const avgFPS = Math.round(totalFPS / samples);
                        const avgRenderTime = Math.round(renderTimeSum / samples * 10) / 10;
                        
                        log(`${test.name}: ${avgFPS} FPS (${avgRenderTime}ms render)`, 
                            avgFPS > 30 ? 'success' : 'warning');
                    }
                }
                
                // Test mixed glow intensities
                log('Testing mixed glow intensities...', 'info');
                particleSystem.clearAllSpeciesGlow();
                
                // Set different intensities for different species
                for (let i = 0; i < Math.min(4, particleSystem.numSpecies); i++) {
                    const intensity = [0.2, 0.5, 0.8, 1.0][i];
                    particleSystem.setSpeciesGlow(i, { intensity, size: 1.5 });
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Final measurement
                let samples = 0;
                let totalFPS = 0;
                
                const finalInterval = setInterval(() => {
                    if (particleSystem.avgFrameTime) {
                        totalFPS += 1000 / particleSystem.avgFrameTime;
                        samples++;
                    }
                }, 200);
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                clearInterval(finalInterval);
                
                if (samples > 0) {
                    const avgFPS = Math.round(totalFPS / samples);
                    log(`Mixed intensities: ${avgFPS} FPS`, avgFPS > 30 ? 'success' : 'warning');
                }
                
                // Restore original settings
                for (let i = 0; i < particleSystem.numSpecies; i++) {
                    particleSystem.setSpeciesGlow(i, originalSettings[i]);
                }
                
                log('‚úì Glow impact profiling completed', 'success');
                
            } catch (error) {
                log(`‚úó Glow impact profiling failed: ${error.message}`, 'error');
            }
        }
        
        async function testPresetSave() {
            log('üíæ Testing preset save functionality...', 'info');
            
            try {
                const { win, particleSystem } = await getApp();
                const presetManager = win.presetManager;
                
                if (!presetManager) {
                    log('‚úó PresetManager not found', 'error');
                    return;
                }
                
                // Create a test preset
                const testPresetKey = 'debug-test-preset-' + Date.now();
                const testPreset = {
                    name: 'Debug Test Preset',
                    version: '1.0',
                    ...particleSystem.exportPreset(),
                    visual: {
                        ...particleSystem.exportPreset().visual,
                        particleSize: 7.5, // Unique test value
                        backgroundColor: '#FF6600' // Unique test color
                    }
                };
                
                log(`Creating test preset: ${testPresetKey}`, 'info');
                
                // Save the preset
                await presetManager.savePreset(testPresetKey, testPreset);
                log('‚úì Preset save completed', 'success');
                
                // Wait a moment for async operations
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verify the preset was saved
                const retrievedPreset = presetManager.getPreset(testPresetKey);
                if (retrievedPreset) {
                    log('‚úì Preset successfully retrieved', 'success');
                    
                    // Verify specific values
                    if (retrievedPreset.name === 'Debug Test Preset') {
                        log('‚úì Preset name preserved', 'success');
                    } else {
                        log(`‚úó Preset name incorrect: ${retrievedPreset.name}`, 'warning');
                    }
                    
                    if (retrievedPreset.visual && retrievedPreset.visual.particleSize === 7.5) {
                        log('‚úì Preset visual data preserved', 'success');
                    } else {
                        log('‚úó Preset visual data not preserved correctly', 'warning');
                    }
                } else {
                    log('‚úó Preset not found after save', 'error');
                }
                
                // Test storage persistence
                log('Testing storage persistence...', 'info');
                const storage = presetManager.storage;
                if (storage) {
                    const allPresets = await storage.getAllPresets();
                    if (allPresets[testPresetKey]) {
                        log('‚úì Preset persisted to storage', 'success');
                    } else {
                        log('‚úó Preset not found in persistent storage', 'warning');
                    }
                } else {
                    log('! Storage system not available for testing', 'info');
                }
                
                // Cleanup - delete test preset
                log('Cleaning up test preset...', 'info');
                await presetManager.deletePreset(testPresetKey);
                
                // Verify deletion
                const deletedPreset = presetManager.getPreset(testPresetKey);
                if (!deletedPreset) {
                    log('‚úì Test preset successfully deleted', 'success');
                } else {
                    log('‚úó Test preset deletion failed', 'warning');
                }
                
                log('‚úÖ Preset save test completed', 'success');
                
            } catch (error) {
                log(`‚úó Preset save test failed: ${error.message}`, 'error');
                console.error('Full error:', error);
            }
        }
        
        async function checkMemoryLeaks() {
            log('üß† Checking for memory leaks...', 'info');
            
            try {
                if (!performance.memory) {
                    log('! Memory API not available in this browser', 'info');
                    return;
                }
                
                // Get initial memory usage
                const initialMemory = {
                    used: performance.memory.usedJSHeapSize,
                    total: performance.memory.totalJSHeapSize,
                    limit: performance.memory.jsHeapSizeLimit
                };
                
                log(`Initial memory usage: ${(initialMemory.used / 1024 / 1024).toFixed(2)}MB`, 'info');
                
                // Perform memory-intensive operations
                log('Performing memory stress test...', 'info');
                
                const { particleSystem } = await getApp();
                
                // Save original particle count
                const originalCount = particleSystem.particlesPerSpecies;
                
                // Test with high particle counts
                const testCounts = [500, 1000, 1500];
                for (const count of testCounts) {
                    log(`Testing with ${count} particles per species...`, 'info');
                    
                    particleSystem.particlesPerSpecies = count;
                    particleSystem.initializeParticlesWithPositions();
                    
                    // Wait for particles to be created and rendered
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Force garbage collection if available
                    if (window.gc) {
                        window.gc();
                    }
                    
                    const currentMemory = performance.memory.usedJSHeapSize;
                    log(`Memory after ${count} particles: ${(currentMemory / 1024 / 1024).toFixed(2)}MB`, 'info');
                }
                
                // Restore original particle count
                particleSystem.particlesPerSpecies = originalCount;
                particleSystem.initializeParticlesWithPositions();
                
                // Wait for cleanup
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Force garbage collection again
                if (window.gc) {
                    window.gc();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Check final memory usage
                const finalMemory = performance.memory.usedJSHeapSize;
                const memoryDiff = finalMemory - initialMemory.used;
                
                log(`Final memory usage: ${(finalMemory / 1024 / 1024).toFixed(2)}MB`, 'info');
                log(`Memory difference: ${(memoryDiff / 1024 / 1024).toFixed(2)}MB`, 'info');
                
                // Check for potential memory leaks
                if (memoryDiff > 50 * 1024 * 1024) { // 50MB threshold
                    log('‚ö†Ô∏è Potential memory leak detected (>50MB increase)', 'warning');
                } else if (memoryDiff > 20 * 1024 * 1024) { // 20MB threshold
                    log('! Moderate memory increase detected (>20MB)', 'info');
                } else {
                    log('‚úì Memory usage appears normal', 'success');
                }
                
                // Check if we're approaching memory limits
                const memoryUsagePercent = (finalMemory / initialMemory.limit) * 100;
                if (memoryUsagePercent > 80) {
                    log(`‚ö†Ô∏è High memory usage: ${memoryUsagePercent.toFixed(1)}% of limit`, 'warning');
                } else {
                    log(`‚úì Memory usage: ${memoryUsagePercent.toFixed(1)}% of limit`, 'success');
                }
                
                log('‚úÖ Memory leak check completed', 'success');
                
            } catch (error) {
                log(`‚úó Memory leak check failed: ${error.message}`, 'error');
            }
        }
        
        // === FIREBASE MANAGEMENT FUNCTIONS ===
        // Merged from cleanup-firebase.html for comprehensive Firebase preset management
        
        async function analyzeFirebaseDatabase() {
            log('‚òÅÔ∏è Analyzing Firebase database...', 'info');
            
            try {
                const { win } = await getApp();
                const { cloudStorage } = await import('./src/utils/CloudStorage.js');
                
                await cloudStorage.initialize();
                log('‚úì Connected to Firebase', 'success');
                
                // Get all presets without filtering
                const allPresets = await cloudStorage.getAllPresets({ limit: 200 });
                log(`Total presets in database: ${allPresets.length}`, 'info');
                
                // Analyze by user
                const userMap = new Map();
                const nameMap = new Map();
                const invalidPresets = [];
                const testPresets = [];
                
                allPresets.forEach(preset => {
                    // Count by user
                    const userId = preset.userId || 'unknown';
                    userMap.set(userId, (userMap.get(userId) || 0) + 1);
                    
                    // Count by name
                    const name = preset.name || 'unnamed';
                    if (!nameMap.has(name)) {
                        nameMap.set(name, []);
                    }
                    nameMap.get(name).push(preset);
                    
                    // Check for invalid names
                    const nameLower = name.toLowerCase();
                    if (nameLower.includes('custom') || 
                        nameLower.includes('automaticsaveasnew') ||
                        nameLower.includes('test') ||
                        nameLower.includes('temp') ||
                        nameLower === 'randomize') {
                        invalidPresets.push(preset);
                    }
                    
                    // Check for test patterns
                    if (nameLower.includes('test') || 
                        nameLower.includes('automaticsaveasnew') ||
                        nameLower.includes('workflowvalidation')) {
                        testPresets.push(preset);
                    }
                });
                
                // Report findings
                log('\\n=== User Distribution ===', 'info');
                userMap.forEach((count, userId) => {
                    log(`User ${userId}: ${count} presets`, 'info');
                });
                
                log('\\n=== Duplicate Names ===', 'warning');
                let duplicateCount = 0;
                nameMap.forEach((presets, name) => {
                    if (presets.length > 1) {
                        duplicateCount++;
                        log(`"${name}": ${presets.length} copies`, 'warning');
                        presets.forEach(p => {
                            log(`  - ID: ${p.id}, User: ${p.userId}, Updated: ${new Date(p.updatedAt).toLocaleString()}`, 'info');
                        });
                    }
                });
                
                if (duplicateCount === 0) {
                    log('No duplicate names found', 'success');
                }
                
                log('\\n=== Invalid Presets ===', 'error');
                log(`Found ${invalidPresets.length} invalid presets:`, 'error');
                invalidPresets.forEach(p => {
                    log(`- "${p.name}" (ID: ${p.id})`, 'error');
                });
                
                log('\\n=== Test Presets ===', 'warning');
                log(`Found ${testPresets.length} test presets`, 'warning');
                
                log('\\n‚úÖ Firebase analysis complete', 'success');
                
            } catch (error) {
                log(`‚úó Firebase analysis failed: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        async function listFirebasePresets() {
            log('üìã Fetching all Firebase presets...', 'info');
            
            try {
                const { cloudStorage } = await import('./src/utils/CloudStorage.js');
                await cloudStorage.initialize();
                
                const presets = await cloudStorage.getAllPresets({ limit: 200 });
                
                log(`\\nFound ${presets.length} presets:`, 'info');
                log('========================================', 'info');
                
                presets.forEach(preset => {
                    const status = preset.status || 'unknown';
                    const created = new Date(preset.createdAt).toLocaleDateString();
                    const updated = new Date(preset.updatedAt).toLocaleDateString();
                    
                    log(`\\nName: ${preset.name}`, 'info');
                    log(`ID: ${preset.id}`, 'info');
                    log(`User: ${preset.userId}`, 'info');
                    log(`Status: ${status}`, 'info');
                    log(`Created: ${created}, Updated: ${updated}`, 'info');
                    log(`Version: ${preset.version || 1}`, 'info');
                });
                
                log('\\n‚úÖ Firebase preset list complete', 'success');
                
            } catch (error) {
                log(`‚úó Failed to list Firebase presets: ${error.message}`, 'error');
            }
        }
        
        async function cleanupFirebaseInvalidPresets() {
            log('üßπ Starting cleanup of invalid Firebase presets...', 'info');
            
            try {
                const { cloudStorage } = await import('./src/utils/CloudStorage.js');
                await cloudStorage.initialize();
                
                const cleanedCount = await cloudStorage.cleanupTestPresets();
                log(`‚úÖ Cleanup completed: ${cleanedCount} presets removed`, 'success');
                
            } catch (error) {
                log(`‚úó Firebase cleanup failed: ${error.message}`, 'error');
                
                // Check if it's an index error
                if (error.message && error.message.includes('index')) {
                    log('‚ö†Ô∏è Firebase index required. Please create the index in Firebase Console.', 'warning');
                    log('Follow the link in the console error to create the index.', 'info');
                }
            }
        }
        
        async function removeFirebaseDuplicates() {
            log('üîç Removing duplicate Firebase presets...', 'info');
            
            try {
                const { cloudStorage } = await import('./src/utils/CloudStorage.js');
                await cloudStorage.initialize();
                
                const allPresets = await cloudStorage.getAllPresets({ limit: 200 });
                
                // Group by name and user
                const groups = new Map();
                allPresets.forEach(preset => {
                    const key = `${preset.userId}_${preset.name}`;
                    if (!groups.has(key)) {
                        groups.set(key, []);
                    }
                    groups.get(key).push(preset);
                });
                
                let deletedCount = 0;
                
                // For each group, keep the newest one
                for (const [key, presets] of groups) {
                    if (presets.length > 1) {
                        log(`\\nFound ${presets.length} copies of "${presets[0].name}"`, 'warning');
                        
                        // Sort by updatedAt (newest first)
                        presets.sort((a, b) => {
                            const dateA = new Date(a.updatedAt || a.createdAt);
                            const dateB = new Date(b.updatedAt || b.createdAt);
                            return dateB - dateA;
                        });
                        
                        // Keep the first (newest), delete the rest
                        log(`Keeping: ${presets[0].id} (updated: ${new Date(presets[0].updatedAt).toLocaleString()})`, 'success');
                        
                        for (let i = 1; i < presets.length; i++) {
                            try {
                                log(`Deleting: ${presets[i].id}`, 'warning');
                                await cloudStorage.deletePreset(presets[i].id);
                                deletedCount++;
                            } catch (error) {
                                log(`Failed to delete ${presets[i].id}: ${error.message}`, 'error');
                            }
                        }
                    }
                }
                
                log(`\\n‚úÖ Deleted ${deletedCount} duplicate presets`, 'success');
                
            } catch (error) {
                log(`‚úó Duplicate removal failed: ${error.message}`, 'error');
            }
        }
        
        async function migrateBuiltInPresets() {
            log('üì§ Migrating built-in presets to Firebase...', 'info');
            
            try {
                const { win } = await getApp();
                const { HybridPresetManager } = await import('./src/utils/HybridPresetManager.js');
                const { SimpleParticleSystem } = await import('./src/core/SimpleParticleSystem.js');
                
                const presetManager = new HybridPresetManager();
                await presetManager.enableCloudSync();
                log('‚úì Cloud sync enabled', 'success');
                
                // Create the built-in presets
                const particleSystem = new SimpleParticleSystem(800, 600);
                
                const builtInPresets = [
                    {
                        key: 'predatorPrey',
                        name: 'Predator-Prey',
                        description: 'Red hunts Green, Green hunts Blue, Blue hunts Red',
                        isBuiltIn: true
                    },
                    {
                        key: 'crystallization',
                        name: 'Crystallization',
                        description: 'Particles form crystal-like structures',
                        isBuiltIn: true
                    },
                    {
                        key: 'vortex',
                        name: 'Vortex',
                        description: 'Circular chase pattern creating swirling vortices',
                        isBuiltIn: true
                    },
                    {
                        key: 'symbiosis',
                        name: 'Symbiosis',
                        description: 'Complex interdependent relationships',
                        isBuiltIn: true
                    },
                    {
                        key: 'dreamtime',
                        name: 'Dreamtime',
                        description: 'Ethereal flowing patterns with glow effects',
                        isBuiltIn: true
                    }
                ];
                
                log(`Uploading ${builtInPresets.length} built-in presets...`, 'info');
                
                let successCount = 0;
                for (const presetInfo of builtInPresets) {
                    try {
                        // Load the preset data from particle system
                        particleSystem.loadPreset(presetInfo.key);
                        const presetData = particleSystem.exportPreset();
                        
                        // Merge with preset info
                        const fullPreset = {
                            ...presetData,
                            ...presetInfo
                        };
                        
                        log(`Uploading preset: ${presetInfo.name}...`, 'info');
                        await presetManager.savePreset(presetInfo.key, fullPreset, true);
                        log(`‚úì Uploaded: ${presetInfo.name}`, 'success');
                        successCount++;
                    } catch (error) {
                        log(`‚úó Failed to upload ${presetInfo.name}: ${error.message}`, 'error');
                    }
                }
                
                log(`\\n‚úÖ Migration complete! Uploaded ${successCount}/${builtInPresets.length} presets`, 
                    successCount === builtInPresets.length ? 'success' : 'warning');
                
            } catch (error) {
                log(`‚úó Migration failed: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        async function deleteAllFirebaseTestPresets() {
            if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL test presets from Firebase. This cannot be undone. Continue?')) {
                log('Firebase test preset deletion cancelled by user', 'info');
                return;
            }
            
            log('üóëÔ∏è Deleting all test presets from Firebase...', 'warning');
            
            try {
                const { cloudStorage } = await import('./src/utils/CloudStorage.js');
                await cloudStorage.initialize();
                
                const allPresets = await cloudStorage.getAllPresets({ limit: 200 });
                
                const testPatterns = [
                    'test', 'temp', 'automaticsaveasnew', 'workflowvalidation',
                    'automaticcreation', 'automaticupdate', 'custom'
                ];
                
                let deletedCount = 0;
                
                for (const preset of allPresets) {
                    const nameLower = (preset.name || '').toLowerCase();
                    const isTest = testPatterns.some(pattern => nameLower.includes(pattern));
                    
                    if (isTest) {
                        try {
                            log(`Deleting test preset: "${preset.name}" (${preset.id})`, 'warning');
                            await cloudStorage.deletePreset(preset.id);
                            deletedCount++;
                        } catch (error) {
                            log(`Failed to delete ${preset.id}: ${error.message}`, 'error');
                        }
                    }
                }
                
                log(`\\n‚úÖ Deleted ${deletedCount} test presets from Firebase`, 'success');
                
            } catch (error) {
                log(`‚úó Test preset deletion failed: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>