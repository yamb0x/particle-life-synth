<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Interface Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #d1d1d1;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        .test-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .test-panel {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #ffffff;
        }
        
        .drawing-interface {
            border: 1px solid #666;
            border-radius: 4px;
            background: #0c0c0c;
            margin-bottom: 15px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-row label {
            min-width: 80px;
            font-size: 14px;
        }
        
        .species-selector {
            background: #333;
            border: 1px solid #555;
            color: #d1d1d1;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .brush-size {
            background: #333;
            border: 1px solid #555;
            color: #d1d1d1;
            padding: 5px;
            border-radius: 4px;
            width: 60px;
        }
        
        .color-picker {
            width: 40px;
            height: 30px;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .pattern-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .pattern-btn {
            background: #444;
            border: 1px solid #666;
            color: #d1d1d1;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .pattern-btn.active {
            background: #4a9eff;
            border-color: #4a9eff;
        }
        
        .clear-btn {
            background: #cc6666;
            border: 1px solid #cc6666;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .info {
            font-size: 12px;
            color: #999;
            margin-top: 10px;
        }
        
        .compact-version {
            max-width: 320px;
        }
        
        .extended-version {
            max-width: 500px;
        }
    </style>
</head>
<body>
    <h1>Visual Drawing Interface Test</h1>
    
    <div class="test-container">
        <!-- Compact Version (Floating UI) -->
        <div class="test-panel compact-version">
            <div class="panel-title">Compact Version (Floating UI)</div>
            
            <canvas class="drawing-interface" id="compact-canvas" width="280" height="180"></canvas>
            
            <div class="controls">
                <div class="control-row">
                    <label>Species:</label>
                    <select class="species-selector" id="compact-species">
                        <option value="0" style="color: #ff6464;">‚óè Red</option>
                        <option value="1" style="color: #64ff64;">‚óè Green</option>
                        <option value="2" style="color: #6496ff;">‚óè Blue</option>
                        <option value="3" style="color: #ffc864;">‚óè Yellow</option>
                        <option value="4" style="color: #ff64ff;">‚óè Purple</option>
                    </select>
                </div>
                
                <div class="control-row">
                    <label>Brush Size:</label>
                    <input type="range" min="5" max="50" value="20" id="compact-brush-slider" style="flex: 1;">
                    <input type="number" class="brush-size" id="compact-brush" value="20" min="5" max="50">
                </div>
                
                <div class="control-row">
                    <label>Color:</label>
                    <div class="color-picker" id="compact-color" style="background: #ff6464;"></div>
                </div>
                
                <div class="pattern-buttons">
                    <button class="pattern-btn active" data-pattern="draw" title="Paint">‚úèÔ∏è</button>
                    <button class="pattern-btn" data-pattern="erase" title="Erase">üßΩ</button>
                    <button class="pattern-btn" data-pattern="cluster" title="Cluster">‚óã</button>
                    <button class="pattern-btn" data-pattern="ring" title="Ring">‚äô</button>
                    <button class="pattern-btn" data-pattern="grid" title="Grid">‚äû</button>
                    <button class="pattern-btn" data-pattern="random" title="Random">‚à¥</button>
                    <button class="pattern-btn clear-btn" id="compact-clear" title="Clear All">üóëÔ∏è</button>
                </div>
            </div>
            
            <div class="info">Click and drag to paint distribution areas. Select species and brush size above.</div>
        </div>
        
        <!-- Particle Rendering Test -->
        <div class="test-panel extended-version">
            <div class="panel-title">Particle Rendering Test</div>
            
            <canvas class="drawing-interface" id="particle-test-canvas" width="460" height="300"></canvas>
            
            <div class="controls">
                <div class="control-row">
                    <button class="pattern-btn" id="spawn-particles">Spawn Particles</button>
                    <button class="pattern-btn" id="clear-particles">Clear Particles</button>
                    <span>Particles: <span id="particle-count">0</span></span>
                </div>
            </div>
            
            <div class="info">
                This shows how particles spawn based on your drawn distributions.<br>
                Draw some distributions in the extended version below, then click "Spawn Particles".
            </div>
        </div>
        
        <!-- Extended Version (Configuration Panel) -->
        <div class="test-panel extended-version">
            <div class="panel-title">Extended Version (Configuration Panel)</div>
            
            <canvas class="drawing-interface" id="extended-canvas" width="460" height="300"></canvas>
            
            <div class="controls">
                <div class="control-row">
                    <label>Species:</label>
                    <select class="species-selector" id="extended-species">
                        <option value="0" style="color: #ff6464;">‚óè Red Species</option>
                        <option value="1" style="color: #64ff64;">‚óè Green Species</option>
                        <option value="2" style="color: #6496ff;">‚óè Blue Species</option>
                        <option value="3" style="color: #ffc864;">‚óè Yellow Species</option>
                        <option value="4" style="color: #ff64ff;">‚óè Purple Species</option>
                    </select>
                    <div class="color-picker" id="extended-color" style="background: #ff6464;"></div>
                </div>
                
                <div class="control-row">
                    <label>Brush Size:</label>
                    <input type="range" min="5" max="80" value="25" id="extended-brush-slider">
                    <input type="number" class="brush-size" id="extended-brush" value="25" min="5" max="80">
                </div>
                
                <div class="control-row">
                    <label>Opacity:</label>
                    <input type="range" min="0.1" max="1.0" step="0.1" value="0.7" id="extended-opacity">
                    <span id="extended-opacity-value">0.7</span>
                </div>
                
                <div class="pattern-buttons">
                    <button class="pattern-btn active" data-pattern="draw">‚úèÔ∏è Paint</button>
                    <button class="pattern-btn" data-pattern="erase">üßΩ Erase</button>
                    <button class="pattern-btn" data-pattern="cluster">‚óã Cluster</button>
                    <button class="pattern-btn" data-pattern="ring">‚äô Ring</button>
                    <button class="pattern-btn" data-pattern="grid">‚äû Grid</button>
                    <button class="pattern-btn" data-pattern="random">‚à¥ Random</button>
                </div>
                
                <div class="control-row">
                    <button class="clear-btn" id="extended-clear">Clear All</button>
                    <button class="pattern-btn" id="extended-save">Save Distribution</button>
                    <button class="pattern-btn" id="extended-load">Load Distribution</button>
                </div>
            </div>
            
            <div class="info">
                Extended version with more controls: opacity, erase tool, save/load.<br>
                This would integrate into the configuration modal's layout tab.
            </div>
        </div>
    </div>

    <script type="module">
        // Test species data
        const testSpecies = [
            { id: 0, name: 'Red', color: { r: 255, g: 100, b: 100 } },
            { id: 1, name: 'Green', color: { r: 100, g: 255, b: 100 } },
            { id: 2, name: 'Blue', color: { r: 100, g: 150, b: 255 } },
            { id: 3, name: 'Yellow', color: { r: 255, g: 200, b: 100 } },
            { id: 4, name: 'Purple', color: { r: 255, g: 100, b: 255 } }
        ];

        class DrawingInterface {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isCompact = options.compact || false;
                this.currentSpecies = 0;
                this.brushSize = this.isCompact ? 20 : 25;
                this.opacity = 0.7;
                this.currentPattern = 'draw';
                this.isDrawing = false;
                this.distributions = new Map(); // species -> array of {x, y, size, opacity}
                
                this.setupCanvas();
                this.setupEventListeners();
                this.render();
            }
            
            setupCanvas() {
                // High DPI support
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                this.width = rect.width;
                this.height = rect.height;
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
            }
            
            handleMouseDown(e) {
                if (this.currentPattern === 'draw' || this.currentPattern === 'erase') {
                    this.isDrawing = true;
                    this.addDistributionPoint(e);
                } else {
                    this.addPresetPattern(e);
                }
            }
            
            handleMouseMove(e) {
                if (this.isDrawing && (this.currentPattern === 'draw' || this.currentPattern === 'erase')) {
                    this.addDistributionPoint(e);
                }
            }
            
            handleMouseUp() {
                this.isDrawing = false;
            }
            
            addDistributionPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.width;
                const y = (e.clientY - rect.top) / this.height;
                
                if (!this.distributions.has(this.currentSpecies)) {
                    this.distributions.set(this.currentSpecies, []);
                }
                
                const points = this.distributions.get(this.currentSpecies);
                
                if (this.currentPattern === 'erase') {
                    // Remove points within brush radius
                    const eraseRadius = this.brushSize / Math.min(this.width, this.height);
                    for (let i = points.length - 1; i >= 0; i--) {
                        const point = points[i];
                        const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                        if (dist < eraseRadius) {
                            points.splice(i, 1);
                        }
                    }
                } else {
                    // Add new point
                    points.push({
                        x,
                        y,
                        size: this.brushSize / Math.min(this.width, this.height),
                        opacity: this.opacity
                    });
                }
                
                this.render();
            }
            
            addPresetPattern(e) {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = (e.clientX - rect.left) / this.width;
                const centerY = (e.clientY - rect.top) / this.height;
                
                if (!this.distributions.has(this.currentSpecies)) {
                    this.distributions.set(this.currentSpecies, []);
                }
                
                const points = this.distributions.get(this.currentSpecies);
                const patternSize = this.brushSize * 3; // Larger for presets
                const radius = patternSize / Math.min(this.width, this.height);
                
                switch (this.currentPattern) {
                    case 'cluster':
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius;
                            points.push({
                                x: centerX + Math.cos(angle) * r,
                                y: centerY + Math.sin(angle) * r,
                                size: this.brushSize / Math.min(this.width, this.height) * 0.5,
                                opacity: this.opacity
                            });
                        }
                        break;
                        
                    case 'ring':
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2;
                            // Use aspect ratio correction for ring
                            const aspectRatio = this.width / this.height;
                            const radiusX = radius * 0.8;
                            const radiusY = radius * 0.8;
                            points.push({
                                x: centerX + Math.cos(angle) * radiusX,
                                y: centerY + Math.sin(angle) * radiusY,
                                size: this.brushSize / Math.min(this.width, this.height) * 0.6,
                                opacity: this.opacity
                            });
                        }
                        break;
                        
                    case 'grid':
                        const gridSize = 5;
                        for (let i = 0; i < gridSize; i++) {
                            for (let j = 0; j < gridSize; j++) {
                                // Maintain square grid spacing in normalized coordinates
                                const spacing = radius * 2 / gridSize;
                                const gx = centerX + (i - gridSize/2 + 0.5) * spacing;
                                const gy = centerY + (j - gridSize/2 + 0.5) * spacing;
                                
                                // Check if point is within circular bounds
                                const distFromCenter = Math.sqrt((gx - centerX) ** 2 + (gy - centerY) ** 2);
                                if (distFromCenter <= radius && gx >= 0 && gx <= 1 && gy >= 0 && gy <= 1) {
                                    points.push({
                                        x: gx,
                                        y: gy,
                                        size: this.brushSize / Math.min(this.width, this.height) * 0.4,
                                        opacity: this.opacity
                                    });
                                }
                            }
                        }
                        break;
                        
                    case 'random':
                        for (let i = 0; i < 25; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * radius;
                            points.push({
                                x: centerX + Math.cos(angle) * r,
                                y: centerY + Math.sin(angle) * r,
                                size: (this.brushSize / Math.min(this.width, this.height)) * (0.3 + Math.random() * 0.4),
                                opacity: this.opacity * (0.6 + Math.random() * 0.4)
                            });
                        }
                        break;
                }
                
                this.render();
            }
            
            render() {
                this.ctx.fillStyle = '#0c0c0c';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.drawGrid();
                this.drawDistributions();
                this.drawBrushPreview();
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#2a2a2a';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 4]);
                
                for (let i = 0; i <= 10; i++) {
                    const pos = (i / 10) * this.width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos, 0);
                    this.ctx.lineTo(pos, this.height);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, pos);
                    this.ctx.lineTo(this.width, pos);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            drawDistributions() {
                for (const [speciesId, points] of this.distributions) {
                    const species = testSpecies[speciesId];
                    if (!species) continue;
                    
                    const color = species.color;
                    
                    for (const point of points) {
                        const x = point.x * this.width;
                        const y = point.y * this.height;
                        const size = point.size * Math.min(this.width, this.height);
                        
                        this.ctx.globalAlpha = point.opacity;
                        this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            drawBrushPreview() {
                // Show current brush size and color
                if (this.mouseX !== undefined && this.mouseY !== undefined) {
                    const species = testSpecies[this.currentSpecies];
                    if (species) {
                        this.ctx.strokeStyle = `rgb(${species.color.r}, ${species.color.g}, ${species.color.b})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([3, 3]);
                        this.ctx.beginPath();
                        this.ctx.arc(this.mouseX, this.mouseY, this.brushSize / 2, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                }
            }
            
            clear() {
                this.distributions.clear();
                this.render();
            }
            
            setSpecies(speciesId) {
                this.currentSpecies = speciesId;
                this.render();
            }
            
            setBrushSize(size) {
                this.brushSize = size;
                this.render();
            }
            
            setOpacity(opacity) {
                this.opacity = opacity;
            }
            
            setPattern(pattern) {
                this.currentPattern = pattern;
            }
            
            exportDistribution() {
                const result = {};
                for (const [speciesId, points] of this.distributions) {
                    result[speciesId] = points;
                }
                return result;
            }
            
            importDistribution(data) {
                this.distributions.clear();
                for (const [speciesId, points] of Object.entries(data)) {
                    this.distributions.set(parseInt(speciesId), points);
                }
                this.render();
            }
        }
        
        // Initialize compact version
        const compactCanvas = document.getElementById('compact-canvas');
        const compactInterface = new DrawingInterface(compactCanvas, { compact: true });
        
        // Initialize extended version
        const extendedCanvas = document.getElementById('extended-canvas');
        const extendedInterface = new DrawingInterface(extendedCanvas, { compact: false });
        
        // Add some demo distributions to show multiple species
        const demoDistributions = {
            0: [ // Red - cluster in top-left
                {x: 0.2, y: 0.2, size: 0.05, opacity: 0.8},
                {x: 0.25, y: 0.18, size: 0.04, opacity: 0.7},
                {x: 0.15, y: 0.25, size: 0.04, opacity: 0.6}
            ],
            1: [ // Green - ring in center
                {x: 0.5, y: 0.4, size: 0.03, opacity: 0.8},
                {x: 0.6, y: 0.5, size: 0.03, opacity: 0.8},
                {x: 0.5, y: 0.6, size: 0.03, opacity: 0.8},
                {x: 0.4, y: 0.5, size: 0.03, opacity: 0.8}
            ],
            2: [ // Blue - grid in bottom-right
                {x: 0.7, y: 0.7, size: 0.025, opacity: 0.7},
                {x: 0.8, y: 0.7, size: 0.025, opacity: 0.7},
                {x: 0.7, y: 0.8, size: 0.025, opacity: 0.7},
                {x: 0.8, y: 0.8, size: 0.025, opacity: 0.7}
            ]
        };
        
        // Apply demo distributions to both interfaces
        compactInterface.importDistribution(demoDistributions);
        extendedInterface.importDistribution(demoDistributions);
        
        // Initialize particle test canvas
        const particleTestCanvas = document.getElementById('particle-test-canvas');
        const particleTestCtx = particleTestCanvas.getContext('2d');
        let testParticles = [];
        
        // Particle rendering test functionality
        function spawnTestParticles() {
            const distribution = extendedInterface.exportDistribution();
            testParticles = [];
            
            Object.entries(distribution).forEach(([speciesId, points]) => {
                const species = testSpecies[parseInt(speciesId)];
                if (!species || !points.length) return;
                
                const particlesPerSpecies = 100;
                
                for (let i = 0; i < particlesPerSpecies; i++) {
                    // Use weighted random selection based on opacity (same as DistributionDrawer)
                    const totalWeight = points.reduce((sum, point) => sum + point.opacity, 0);
                    let randomWeight = Math.random() * totalWeight;
                    
                    let selectedPoint = points[0];
                    for (const point of points) {
                        randomWeight -= point.opacity;
                        if (randomWeight <= 0) {
                            selectedPoint = point;
                            break;
                        }
                    }
                    
                    // Add variation around selected point (same as particle system)
                    const variation = selectedPoint.size * 0.5;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * variation * Math.min(particleTestCanvas.width, particleTestCanvas.height);
                    
                    const x = selectedPoint.x * particleTestCanvas.width + Math.cos(angle) * radius;
                    const y = selectedPoint.y * particleTestCanvas.height + Math.sin(angle) * radius;
                    
                    // Clamp to canvas bounds
                    const clampedX = Math.max(2, Math.min(particleTestCanvas.width - 2, x));
                    const clampedY = Math.max(2, Math.min(particleTestCanvas.height - 2, y));
                    
                    testParticles.push({
                        x: clampedX,
                        y: clampedY,
                        color: species.color,
                        species: parseInt(speciesId)
                    });
                }
            });
            
            renderTestParticles();
            document.getElementById('particle-count').textContent = testParticles.length;
        }
        
        function renderTestParticles() {
            particleTestCtx.fillStyle = '#0c0c0c';
            particleTestCtx.fillRect(0, 0, particleTestCanvas.width, particleTestCanvas.height);
            
            // Draw grid for reference
            particleTestCtx.strokeStyle = '#2a2a2a';
            particleTestCtx.lineWidth = 1;
            particleTestCtx.setLineDash([2, 4]);
            
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * particleTestCanvas.width;
                const y = (i / 10) * particleTestCanvas.height;
                
                particleTestCtx.beginPath();
                particleTestCtx.moveTo(x, 0);
                particleTestCtx.lineTo(x, particleTestCanvas.height);
                particleTestCtx.stroke();
                
                particleTestCtx.beginPath();
                particleTestCtx.moveTo(0, y);
                particleTestCtx.lineTo(particleTestCanvas.width, y);
                particleTestCtx.stroke();
            }
            particleTestCtx.setLineDash([]);
            
            // Draw particles
            testParticles.forEach(particle => {
                const color = particle.color;
                particleTestCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                particleTestCtx.beginPath();
                particleTestCtx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                particleTestCtx.fill();
            });
        }
        
        function clearTestParticles() {
            testParticles = [];
            particleTestCtx.fillStyle = '#0c0c0c';
            particleTestCtx.fillRect(0, 0, particleTestCanvas.width, particleTestCanvas.height);
            document.getElementById('particle-count').textContent = '0';
        }
        
        // Event handlers for particle test
        document.getElementById('spawn-particles').addEventListener('click', spawnTestParticles);
        document.getElementById('clear-particles').addEventListener('click', clearTestParticles);
        
        // Initial render
        clearTestParticles();
        
        // Compact controls
        document.getElementById('compact-species').addEventListener('change', (e) => {
            compactInterface.setSpecies(parseInt(e.target.value));
            const color = testSpecies[parseInt(e.target.value)].color;
            document.getElementById('compact-color').style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
        });
        
        document.getElementById('compact-brush-slider').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            compactInterface.setBrushSize(size);
            document.getElementById('compact-brush').value = size;
        });
        
        document.getElementById('compact-brush').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            compactInterface.setBrushSize(size);
            document.getElementById('compact-brush-slider').value = size;
        });
        
        document.getElementById('compact-clear').addEventListener('click', () => {
            compactInterface.clear();
        });
        
        // Extended controls
        document.getElementById('extended-species').addEventListener('change', (e) => {
            extendedInterface.setSpecies(parseInt(e.target.value));
            const color = testSpecies[parseInt(e.target.value)].color;
            document.getElementById('extended-color').style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
        });
        
        document.getElementById('extended-brush-slider').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            extendedInterface.setBrushSize(size);
            document.getElementById('extended-brush').value = size;
        });
        
        document.getElementById('extended-brush').addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            extendedInterface.setBrushSize(size);
            document.getElementById('extended-brush-slider').value = size;
        });
        
        document.getElementById('extended-opacity').addEventListener('input', (e) => {
            const opacity = parseFloat(e.target.value);
            extendedInterface.setOpacity(opacity);
            document.getElementById('extended-opacity-value').textContent = opacity.toFixed(1);
        });
        
        document.getElementById('extended-clear').addEventListener('click', () => {
            extendedInterface.clear();
        });
        
        document.getElementById('extended-save').addEventListener('click', () => {
            const data = extendedInterface.exportDistribution();
            localStorage.setItem('testDistribution', JSON.stringify(data));
            alert('Distribution saved to localStorage');
        });
        
        document.getElementById('extended-load').addEventListener('click', () => {
            const data = localStorage.getItem('testDistribution');
            if (data) {
                extendedInterface.importDistribution(JSON.parse(data));
                alert('Distribution loaded from localStorage');
            } else {
                alert('No saved distribution found');
            }
        });
        
        // Pattern button handlers for both interfaces
        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const panel = e.target.closest('.test-panel');
                const isCompact = panel.classList.contains('compact-version');
                const drawingInterface = isCompact ? compactInterface : extendedInterface;
                
                // Update button states
                panel.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                // Set pattern
                drawingInterface.setPattern(e.target.dataset.pattern);
            });
        });
        
        // Mouse tracking for brush preview
        [compactCanvas, extendedCanvas].forEach((canvas, index) => {
            const drawingInterface = index === 0 ? compactInterface : extendedInterface;
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                drawingInterface.mouseX = e.clientX - rect.left;
                drawingInterface.mouseY = e.clientY - rect.top;
                drawingInterface.render();
            });
            
            canvas.addEventListener('mouseleave', () => {
                drawingInterface.mouseX = undefined;
                drawingInterface.mouseY = undefined;
                drawingInterface.render();
            });
        });
    </script>
</body>
</html>