<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Particle Life Synth - Automated Test Suite</title>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #fff;
            --text-secondary: #aaa;
            --accent-success: #4CAF50;
            --accent-error: #f44336;
            --accent-warning: #ff9800;
            --accent-info: #2196F3;
        }
        
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .header {
            background: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent-info);
        }
        
        .test-stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 18px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: calc(100vh - 60px);
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }
        
        .main {
            display: flex;
            flex-direction: column;
        }
        
        .test-runner {
            padding: 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid #333;
        }
        
        .app-container {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .test-group {
            margin-bottom: 20px;
        }
        
        .test-group h3 {
            margin: 0 0 10px 0;
            color: var(--accent-info);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .test-item {
            background: var(--bg-tertiary);
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-item:hover {
            background: #333;
        }
        
        .test-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }
        
        .test-status.running { 
            background: var(--accent-warning);
            animation: pulse 1s infinite;
        }
        
        .test-status.passed { background: var(--accent-success); }
        .test-status.failed { background: var(--accent-error); }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .test-name {
            flex: 1;
            font-size: 13px;
        }
        
        .test-time {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #333;
            border-color: #555;
        }
        
        button.primary {
            background: var(--accent-info);
            border-color: var(--accent-info);
            color: #000;
        }
        
        button.primary:hover {
            background: #1976D2;
        }
        
        .console {
            background: #000;
            padding: 15px;
            font-size: 12px;
            line-height: 1.5;
            height: 200px;
            overflow-y: auto;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .console-entry {
            margin: 2px 0;
        }
        
        .console-entry.info { color: #aaa; }
        .console-entry.success { color: var(--accent-success); }
        .console-entry.error { color: var(--accent-error); }
        .console-entry.warning { color: var(--accent-warning); }
        .console-entry.debug { color: #bb86fc; }
        
        .timestamp {
            color: #666;
            margin-right: 8px;
        }
        
        .coverage-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        .coverage-fill {
            height: 100%;
            background: var(--accent-success);
            transition: width 0.3s;
        }
        
        .test-details {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
            display: none;
        }
        
        .test-details.show {
            display: block;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .detail-label {
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧪 Particle Life Synth - Test Suite</h1>
        <div class="test-stats">
            <div class="stat">
                <span>Tests:</span>
                <span class="stat-value" id="total-tests">0</span>
            </div>
            <div class="stat" style="color: var(--accent-success);">
                <span>Passed:</span>
                <span class="stat-value" id="passed-tests">0</span>
            </div>
            <div class="stat" style="color: var(--accent-error);">
                <span>Failed:</span>
                <span class="stat-value" id="failed-tests">0</span>
            </div>
            <div class="stat">
                <span>Coverage:</span>
                <span class="stat-value" id="coverage">0%</span>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div class="controls">
                <button class="primary" onclick="runAllTests()">Run All Tests</button>
                <button onclick="clearResults()">Clear</button>
            </div>
            
            <div class="test-group">
                <h3>UI Parameters</h3>
                <div class="test-list" id="ui-tests"></div>
            </div>
            
            <div class="test-group">
                <h3>Particle System</h3>
                <div class="test-list" id="system-tests"></div>
            </div>
            
            <div class="test-group">
                <h3>Presets & Storage</h3>
                <div class="test-list" id="storage-tests"></div>
            </div>
            
            <div class="test-group">
                <h3>Integration</h3>
                <div class="test-list" id="integration-tests"></div>
            </div>
            
            <div class="coverage-bar">
                <div class="coverage-fill" id="coverage-bar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="main">
            <div class="test-runner">
                <h3>Test Output</h3>
                <div class="console" id="console"></div>
                <div class="test-details" id="test-details"></div>
            </div>
            
            <div class="app-container">
                <iframe id="app-frame" src="/"></iframe>
            </div>
        </div>
    </div>

    <script>
        // Test Framework
        class TestRunner {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
                this.frame = document.getElementById('app-frame');
                this.console = document.getElementById('console');
                this.currentTest = null;
                this.setupTests();
                this.setupConsolidatedTests(); // Add auto-test.html functions
            }
            
            log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `console-entry ${type}`;
                const time = new Date().toLocaleTimeString();
                entry.innerHTML = `<span class="timestamp">${time}</span>${message}`;
                this.console.appendChild(entry);
                this.console.scrollTop = this.console.scrollHeight;
            }
            
            async waitFor(condition, timeout = 5000, description = 'condition') {
                const start = Date.now();
                while (Date.now() - start < timeout) {
                    try {
                        if (await condition()) return true;
                    } catch (e) {
                        // Continue waiting
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                throw new Error(`Timeout waiting for ${description}`);
            }
            
            async getAppContext() {
                const win = this.frame.contentWindow;
                const doc = this.frame.contentDocument;
                
                // Wait for particle system
                await this.waitFor(() => win.particleSystem, 10000, 'particleSystem');
                
                return {
                    window: win,
                    document: doc,
                    particleSystem: win.particleSystem,
                    mainUI: win.mainUI,
                    presetModal: win.presetModal
                };
            }
            
            async findMainUIElement(selector) {
                const ctx = await this.getAppContext();
                const elements = ctx.document.querySelectorAll(selector);
                
                // Find element NOT in modal
                for (const el of elements) {
                    if (!el.closest('.preset-modal')) {
                        return el;
                    }
                }
                return null;
            }
            
            setupTests() {
                // UI Parameter Tests
                this.addTest('ui', 'particle-size-control', 'Particle Size Control', async () => {
                    const ctx = await this.getAppContext();
                    const slider = await this.findMainUIElement('#particle-size');
                    
                    if (!slider) throw new Error('Particle size slider not found');
                    
                    const oldSize = ctx.particleSystem.particleSize;
                    const testValue = 15.5;
                    
                    // Change value
                    slider.value = testValue;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Verify changes
                    const newSize = ctx.particleSystem.particleSize;
                    const speciesSize = ctx.particleSystem.species[0]?.size;
                    const display = ctx.document.getElementById('particle-size-value');
                    
                    this.assert(newSize === testValue, `Particle size updated to ${testValue}`);
                    this.assert(speciesSize === testValue, `Species size updated to ${testValue}`);
                    this.assert(display?.textContent === '15.5', 'Display shows correct value');
                    
                    return { oldSize, newSize, speciesSize };
                });
                
                this.addTest('ui', 'species-count-control', 'Species Count Control', async () => {
                    const ctx = await this.getAppContext();
                    const slider = await this.findMainUIElement('#species-count');
                    
                    if (!slider) throw new Error('Species count slider not found');
                    
                    // Test range
                    this.assert(slider.min === '1', 'Min value is 1');
                    this.assert(slider.max === '20', 'Max value is 20');
                    
                    // Test changing to max
                    slider.value = 20;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    this.assert(ctx.particleSystem.numSpecies === 20, 'Species count set to 20');
                    
                    // Test changing to min
                    slider.value = 1;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    this.assert(ctx.particleSystem.numSpecies === 1, 'Species count set to 1');
                    
                    // Reset to 5
                    slider.value = 5;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    return { finalCount: ctx.particleSystem.numSpecies };
                });
                
                this.addTest('ui', 'background-color-control', 'Background Color Control', async () => {
                    const ctx = await this.getAppContext();
                    const input = ctx.document.getElementById('background-color');
                    
                    if (!input) throw new Error('Background color input not found');
                    
                    const testColor = '#FF00FF';
                    input.value = testColor;
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    this.assert(
                        ctx.particleSystem.backgroundColor.toUpperCase() === testColor,
                        `Background color set to ${testColor}`
                    );
                    
                    return { color: ctx.particleSystem.backgroundColor };
                });
                
                this.addTest('ui', 'event-listener-attachment', 'Event Listener Attachment', async () => {
                    const ctx = await this.getAppContext();
                    
                    // Check if MainUI has required methods
                    this.assert(ctx.mainUI !== undefined, 'MainUI exists');
                    this.assert(typeof ctx.mainUI.safeAddEventListener === 'function', 
                        'safeAddEventListener method exists');
                    
                    // Check critical elements exist
                    const elements = ['particle-size', 'species-count', 'background-color'];
                    for (const id of elements) {
                        const el = await this.findMainUIElement(`#${id}`);
                        this.assert(el !== null, `Element #${id} exists in main UI`);
                    }
                    
                    return { mainUIExists: true, methodsExist: true };
                });
                
                // Particle System Tests
                this.addTest('system', 'species-management', 'Species Management', async () => {
                    const ctx = await this.getAppContext();
                    const ps = ctx.particleSystem;
                    
                    // Test setSpeciesCount
                    this.assert(typeof ps.setSpeciesCount === 'function', 'setSpeciesCount exists');
                    
                    const result = ps.setSpeciesCount(8);
                    this.assert(result === true, 'setSpeciesCount returns true');
                    this.assert(ps.numSpecies === 8, 'Species count updated');
                    this.assert(ps.species.length === 8, 'Species array resized');
                    
                    // Test species properties
                    for (let i = 0; i < ps.species.length; i++) {
                        const species = ps.species[i];
                        this.assert(species.size === ps.particleSize, 
                            `Species ${i} size matches particle size`);
                        this.assert(species.color !== undefined, `Species ${i} has color`);
                    }
                    
                    return { speciesCount: ps.numSpecies };
                });
                
                this.addTest('system', 'force-matrices', 'Force Matrices', async () => {
                    const ctx = await this.getAppContext();
                    const ps = ctx.particleSystem;
                    
                    // Check matrix dimensions
                    this.assert(ps.socialForce.length === ps.numSpecies, 
                        'Social force matrix rows match species count');
                    this.assert(ps.socialForce[0].length === ps.numSpecies, 
                        'Social force matrix cols match species count');
                    
                    // Test setting force
                    const testForce = 0.5;
                    ps.setSocialForce(0, 1, testForce);
                    this.assert(ps.socialForce[0][1] === testForce, 
                        'Social force updated correctly');
                    
                    return { matrixSize: ps.numSpecies };
                });
                
                // Storage Tests
                this.addTest('storage', 'preset-export', 'Preset Export', async () => {
                    const ctx = await this.getAppContext();
                    const preset = ctx.particleSystem.exportPreset();
                    
                    this.assert(preset !== undefined, 'Preset exported');
                    this.assert(preset.species !== undefined, 'Has species data');
                    this.assert(preset.physics !== undefined, 'Has physics data');
                    this.assert(preset.visual !== undefined, 'Has visual data');
                    this.assert(preset.forces !== undefined, 'Has forces data');
                    
                    return { presetKeys: Object.keys(preset) };
                });
                
                this.addTest('storage', 'color-preservation', 'Color Preservation on Modal Open', async () => {
                    const ctx = await this.getAppContext();
                    
                    // Helper to normalize colors for comparison
                    const normalizeColor = (color) => {
                        if (typeof color === 'string') return color.toUpperCase();
                        if (color && typeof color === 'object' && color.r !== undefined) {
                            const r = Math.round(color.r).toString(16).padStart(2, '0');
                            const g = Math.round(color.g).toString(16).padStart(2, '0');
                            const b = Math.round(color.b).toString(16).padStart(2, '0');
                            return `#${r}${g}${b}`.toUpperCase();
                        }
                        return null;
                    };
                    
                    // Set custom colors
                    if (ctx.particleSystem.species[0]) {
                        ctx.particleSystem.species[0].color = '#FF0000';
                    }
                    if (ctx.particleSystem.species[1]) {
                        ctx.particleSystem.species[1].color = '#00FF00';
                    }
                    
                    const colorsBefore = ctx.particleSystem.species.slice(0, 2)
                        .map(s => normalizeColor(s?.color));
                    
                    // Open modal
                    ctx.presetModal.open(null);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    const colorsAfter = ctx.particleSystem.species.slice(0, 2)
                        .map(s => normalizeColor(s?.color));
                    
                    // Close modal
                    ctx.presetModal.close();
                    
                    this.assert(
                        colorsBefore[0] === colorsAfter[0] && colorsBefore[1] === colorsAfter[1],
                        'Colors preserved when opening modal'
                    );
                    
                    return { colorsBefore, colorsAfter };
                });
                
                // Integration Tests
                this.addTest('integration', 'full-parameter-cycle', 'Full Parameter Update Cycle', async () => {
                    const ctx = await this.getAppContext();
                    
                    // Change multiple parameters
                    const sizeSlider = await this.findMainUIElement('#particle-size');
                    const speciesSlider = await this.findMainUIElement('#species-count');
                    const bgInput = ctx.document.getElementById('background-color');
                    
                    // Set values
                    sizeSlider.value = 8;
                    sizeSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    speciesSlider.value = 6;
                    speciesSlider.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    bgInput.value = '#336699';
                    bgInput.dispatchEvent(new Event('change', { bubbles: true }));
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Verify all changes
                    this.assert(ctx.particleSystem.particleSize === 8, 'Size updated');
                    this.assert(ctx.particleSystem.numSpecies === 6, 'Species updated');
                    this.assert(ctx.particleSystem.backgroundColor === '#336699', 'BG updated');
                    
                    // Export and verify preset
                    const preset = ctx.particleSystem.exportPreset();
                    this.assert(preset.visual.particleSize === 8, 'Preset has correct size');
                    this.assert(preset.species.count === 6, 'Preset has correct species count');
                    this.assert(preset.visual.backgroundColor === '#336699', 'Preset has correct BG');
                    
                    return { preset };
                });
            }
            
            addTest(category, id, name, testFn) {
                // Prevent duplicate tests
                if (this.tests.has(id)) {
                    return;
                }
                this.tests.set(id, { category, name, fn: testFn });
                this.createTestUI(category, id, name);
            }
            
            createTestUI(category, id, name) {
                const container = document.getElementById(`${category}-tests`);
                // Check if UI already exists
                if (document.getElementById(`test-${id}`)) {
                    return;
                }
                const item = document.createElement('div');
                item.className = 'test-item';
                item.id = `test-${id}`;
                item.innerHTML = `
                    <div class="test-status"></div>
                    <div class="test-name">${name}</div>
                    <div class="test-time"></div>
                `;
                item.onclick = () => this.runTest(id);
                container.appendChild(item);
            }
            
            assert(condition, message) {
                if (!condition) {
                    throw new Error(`Assertion failed: ${message}`);
                }
                this.log(`✓ ${message}`, 'success');
            }
            
            async runTest(id) {
                const test = this.tests.get(id);
                if (!test) return;
                
                const item = document.getElementById(`test-${id}`);
                const status = item.querySelector('.test-status');
                const timeEl = item.querySelector('.test-time');
                
                status.className = 'test-status running';
                this.currentTest = id;
                
                this.log(`\n=== Running: ${test.name} ===`, 'info');
                const startTime = Date.now();
                
                try {
                    const result = await test.fn();
                    const duration = Date.now() - startTime;
                    
                    status.className = 'test-status passed';
                    timeEl.textContent = `${duration}ms`;
                    
                    this.results.set(id, { passed: true, duration, result });
                    this.log(`✅ Test passed in ${duration}ms`, 'success');
                    
                    if (result) {
                        this.showTestDetails(id, result);
                    }
                } catch (error) {
                    const duration = Date.now() - startTime;
                    
                    status.className = 'test-status failed';
                    timeEl.textContent = `${duration}ms`;
                    
                    this.results.set(id, { passed: false, duration, error });
                    this.log(`❌ Test failed: ${error.message}`, 'error');
                }
                
                this.updateStats();
            }
            
            async runAllTests() {
                this.results.clear();
                this.console.innerHTML = '';
                this.log('Starting test suite...', 'info');
                
                // Wait for app to load
                await this.waitFor(() => this.frame.contentWindow.particleSystem, 10000, 'app initialization');
                this.log('✓ App initialized', 'success');
                
                for (const [id, test] of this.tests) {
                    await this.runTest(id);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                this.log('\n=== Test Suite Complete ===', 'info');
                const passed = Array.from(this.results.values()).filter(r => r.passed).length;
                const total = this.results.size;
                this.log(`Results: ${passed}/${total} passed (${Math.round(passed/total * 100)}%)`, 
                    passed === total ? 'success' : 'warning');
            }
            
            updateStats() {
                const results = Array.from(this.results.values());
                const passed = results.filter(r => r.passed).length;
                const failed = results.filter(r => !r.passed).length;
                const total = this.tests.size;
                const coverage = total > 0 ? Math.round((results.length / total) * 100) : 0;
                
                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('coverage').textContent = `${coverage}%`;
                document.getElementById('coverage-bar').style.width = `${coverage}%`;
            }
            
            showTestDetails(id, result) {
                const details = document.getElementById('test-details');
                details.className = 'test-details show';
                
                let html = '<h4>Test Result Details</h4>';
                for (const [key, value] of Object.entries(result)) {
                    html += `<div class="detail-row">
                        <span class="detail-label">${key}:</span>
                        <span>${JSON.stringify(value)}</span>
                    </div>`;
                }
                details.innerHTML = html;
            }
            
            clearResults() {
                this.results.clear();
                this.console.innerHTML = '';
                document.querySelectorAll('.test-status').forEach(el => {
                    el.className = 'test-status';
                });
                document.querySelectorAll('.test-time').forEach(el => {
                    el.textContent = '';
                });
                document.getElementById('test-details').className = 'test-details';
                this.updateStats();
            }
            
            // === CONSOLIDATED AUTO-TEST FUNCTIONS ===
            // Merged from auto-test.html as per MASTER_DEVELOPMENT_PLAN.md
            
            async testSpeciesCountChange() {
                try {
                    const ctx = await this.getAppContext();
                    const originalCount = ctx.particleSystem.numSpecies;
                    const testCount = originalCount === 5 ? 8 : 5;
                    
                    // Test species count change
                    if (ctx.particleSystem.setSpeciesCount) {
                        const result = ctx.particleSystem.setSpeciesCount(testCount);
                        if (!result) throw new Error('setSpeciesCount returned false');
                        
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        if (ctx.particleSystem.numSpecies !== testCount) {
                            throw new Error(`Species count not updated: expected ${testCount}, got ${ctx.particleSystem.numSpecies}`);
                        }
                        
                        // Check particles are moving
                        const particle = ctx.particleSystem.particles[0];
                        const initialPos = { x: particle.x, y: particle.y };
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const finalPos = { x: particle.x, y: particle.y };
                        const moved = Math.abs(finalPos.x - initialPos.x) > 0.1 || Math.abs(finalPos.y - initialPos.y) > 0.1;
                        
                        if (!moved) throw new Error('Particles appear frozen after species count change');
                        
                        // Restore original count
                        ctx.particleSystem.setSpeciesCount(originalCount);
                        
                        return { passed: true, message: `Species count change ${originalCount}→${testCount} successful` };
                    } else {
                        throw new Error('setSpeciesCount method not found');
                    }
                } catch (error) {
                    return { passed: false, message: error.message };
                }
            }
            
            async testTrailRendering() {
                try {
                    const ctx = await this.getAppContext();
                    const originalTrail = ctx.particleSystem.trailEnabled;
                    
                    // Test trail toggle
                    ctx.particleSystem.trailEnabled = true;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    ctx.particleSystem.trailEnabled = false;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Restore original state
                    ctx.particleSystem.trailEnabled = originalTrail;
                    
                    return { passed: true, message: 'Trail rendering toggle successful' };
                } catch (error) {
                    return { passed: false, message: error.message };
                }
            }
            
            async testUIStateManager() {
                try {
                    const ctx = await this.getAppContext();
                    
                    if (!ctx.window.UIStateManager) {
                        throw new Error('UIStateManager not found');
                    }
                    
                    return { passed: true, message: 'UIStateManager available' };
                } catch (error) {
                    return { passed: false, message: error.message };
                }
            }
            
            async testDOMHelpers() {
                try {
                    const ctx = await this.getAppContext();
                    
                    if (!ctx.window.DOMHelpers) {
                        throw new Error('DOMHelpers not found');
                    }
                    
                    return { passed: true, message: 'DOMHelpers available' };
                } catch (error) {
                    return { passed: false, message: error.message };
                }
            }
            
            async testPresetSystem() {
                try {
                    const ctx = await this.getAppContext();
                    
                    if (!ctx.window.presetManager) {
                        throw new Error('PresetManager not found');
                    }
                    
                    // Test preset export
                    const exportedPreset = ctx.particleSystem.exportPreset();
                    if (!exportedPreset || !exportedPreset.name) {
                        throw new Error('Preset export failed');
                    }
                    
                    return { passed: true, message: 'Preset system functional' };
                } catch (error) {
                    return { passed: false, message: error.message };
                }
            }
            
            // Add the new tests to the test registry
            setupConsolidatedTests() {
                // Add tests from auto-test.html
                this.addTest('system', 'species-count-change', 'Species Count Change', () => this.testSpeciesCountChange());
                this.addTest('system', 'trail-rendering', 'Trail Rendering', () => this.testTrailRendering());
                this.addTest('system', 'ui-state-manager', 'UI State Manager', () => this.testUIStateManager());
                this.addTest('system', 'dom-helpers', 'DOM Helpers', () => this.testDOMHelpers());
                this.addTest('storage', 'preset-system', 'Preset System', () => this.testPresetSystem());
            }
        }
        
        // Initialize test runner
        const runner = new TestRunner();
        
        // Global functions
        window.runAllTests = () => runner.runAllTests();
        window.clearResults = () => runner.clearResults();
        
        // Auto-run tests after load (only once)
        let hasAutoRun = false;
        runner.frame.onload = async () => {
            if (!hasAutoRun) {
                hasAutoRun = true;
                await new Promise(resolve => setTimeout(resolve, 3000));
                runner.runAllTests();
            }
        };
    </script>
</body>
</html>
</content>