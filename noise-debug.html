<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Debug & Calibration</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SF Mono', Monaco, monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .panel {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
        }
        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .canvas-item {
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
        }
        h3 {
            color: #4a9eff;
            margin-bottom: 10px;
            font-size: 12px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        select, button {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            margin: 5px 0;
            font-size: 11px;
        }
        button:hover {
            background: #444;
        }
        .value {
            color: #4a9eff;
            font-weight: bold;
        }
        .debug-info {
            font-size: 10px;
            color: #888;
            margin-top: 5px;
            line-height: 1.4;
        }
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        .preset-buttons button {
            font-size: 10px;
            padding: 8px;
        }
        .stats {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .warning {
            color: #ff6b6b;
            font-size: 10px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h3>Noise Debug Controls</h3>
            
            <div class="control-group">
                <label>Pattern</label>
                <select id="pattern">
                    <option value="perlin">Perlin</option>
                    <option value="simplex">Simplex</option>
                    <option value="voronoi">Voronoi</option>
                    <option value="worley">Worley</option>
                    <option value="fbm">FBM</option>
                    <option value="ridged">Ridged</option>
                    <option value="turbulence">Turbulence</option>
                    <option value="curl">Curl</option>
                    <option value="flow">Flow</option>
                    <option value="waves">Waves</option>
                    <option value="cubic">Cubic</option>
                    <option value="cellular">Cellular</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>
                    Scale <span class="value" id="scale-value">3.0</span>
                </label>
                <input type="range" id="scale" min="0.1" max="10.0" step="0.1" value="3.0">
                <div class="debug-info">
                    Frequency of pattern repetition.<br>
                    Lower = larger features
                </div>
            </div>
            
            <div class="control-group">
                <label>
                    Amplitude <span class="value" id="amplitude-value">1.0</span>
                </label>
                <input type="range" id="amplitude" min="0" max="2" step="0.01" value="1.0">
            </div>
            
            <div class="control-group">
                <label>
                    Time Scale <span class="value" id="timeScale-value">0.5</span>
                </label>
                <input type="range" id="timeScale" min="0" max="2" step="0.01" value="0.5">
            </div>
            
            <div class="control-group">
                <label>
                    Contrast <span class="value" id="contrast-value">1.0</span>
                </label>
                <input type="range" id="contrast" min="0.5" max="3" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>
                    Animation Speed <span class="value" id="animation-value">0.01</span>
                </label>
                <input type="range" id="animation" min="0" max="0.05" step="0.001" value="0.01">
                <div class="debug-info">
                    Time increment per frame.<br>
                    0 = frozen, 0.05 = very fast
                </div>
            </div>
            
            <div class="control-group">
                <label>
                    Octaves <span class="value" id="octaves-value">3</span>
                </label>
                <input type="range" id="octaves" min="1" max="8" step="1" value="3">
                <div class="debug-info">
                    Number of noise layers.<br>
                    More = finer detail
                </div>
            </div>
            
            <div class="preset-buttons">
                <button onclick="applyPreset('smooth')">Smooth Flow</button>
                <button onclick="applyPreset('detailed')">Detailed</button>
                <button onclick="applyPreset('cellular')">Cellular</button>
                <button onclick="applyPreset('turbulent')">Turbulent</button>
            </div>
            
            <div class="stats">
                <div class="stat-row">
                    <span>Min:</span>
                    <span class="value" id="min">0.00</span>
                </div>
                <div class="stat-row">
                    <span>Max:</span>
                    <span class="value" id="max">0.00</span>
                </div>
                <div class="stat-row">
                    <span>Range:</span>
                    <span class="value" id="range">0.00</span>
                </div>
                <div class="stat-row">
                    <span>Variance:</span>
                    <span class="value" id="variance">0.00</span>
                </div>
                <div class="stat-row">
                    <span>Time:</span>
                    <span class="value" id="time">0.00</span>
                </div>
                <div class="stat-row">
                    <span>Frame:</span>
                    <span class="value" id="frame">0</span>
                </div>
            </div>
            
            <div id="warning" class="warning"></div>
        </div>
        
        <div class="panel">
            <h3>Noise Visualization at Different Scales</h3>
            <div class="canvas-grid">
                <div class="canvas-item">
                    <h3>Scale × 0.5</h3>
                    <canvas id="canvas1" width="200" height="200"></canvas>
                    <div class="debug-info" id="info1"></div>
                </div>
                <div class="canvas-item">
                    <h3>Scale × 1.0</h3>
                    <canvas id="canvas2" width="200" height="200"></canvas>
                    <div class="debug-info" id="info2"></div>
                </div>
                <div class="canvas-item">
                    <h3>Scale × 2.0</h3>
                    <canvas id="canvas3" width="200" height="200"></canvas>
                    <div class="debug-info" id="info3"></div>
                </div>
                <div class="canvas-item">
                    <h3>X Component</h3>
                    <canvas id="canvasX" width="200" height="200"></canvas>
                    <div class="debug-info" id="infoX"></div>
                </div>
                <div class="canvas-item">
                    <h3>Y Component</h3>
                    <canvas id="canvasY" width="200" height="200"></canvas>
                    <div class="debug-info" id="infoY"></div>
                </div>
                <div class="canvas-item">
                    <h3>Vector Field</h3>
                    <canvas id="canvasV" width="200" height="200"></canvas>
                    <div class="debug-info" id="infoV"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Create a simplified noise generator for debugging
        class SimpleNoiseDebugger {
            constructor() {
                this.time = 0;
                this.pattern = 'perlin';
                this.scale = 3.0;
                this.amplitude = 1.0;
                this.timeScale = 0.5;
                this.contrast = 1.0;
                this.animationSpeed = 0.01;
                this.octaves = 3;
                
                console.log('SimpleNoiseDebugger initialized with:', {
                    animationSpeed: this.animationSpeed,
                    timeScale: this.timeScale,
                    pattern: this.pattern
                });
                
                // Simple permutation table
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = i;
                }
                // Shuffle
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                for (let i = 0; i < 256; i++) {
                    this.perm[256 + i] = this.perm[i];
                }
                
                this.setupCanvases();
                this.setupControls();
                this.animate();
            }
            
            setupCanvases() {
                this.canvases = [
                    { ctx: document.getElementById('canvas1').getContext('2d'), scale: 0.5, info: 'info1' },
                    { ctx: document.getElementById('canvas2').getContext('2d'), scale: 1.0, info: 'info2' },
                    { ctx: document.getElementById('canvas3').getContext('2d'), scale: 2.0, info: 'info3' },
                    { ctx: document.getElementById('canvasX').getContext('2d'), scale: 1.0, info: 'infoX', component: 'x' },
                    { ctx: document.getElementById('canvasY').getContext('2d'), scale: 1.0, info: 'infoY', component: 'y' },
                    { ctx: document.getElementById('canvasV').getContext('2d'), scale: 1.0, info: 'infoV', component: 'vector' }
                ];
            }
            
            setupControls() {
                document.getElementById('pattern').addEventListener('change', (e) => {
                    this.pattern = e.target.value;
                });
                
                document.getElementById('scale').addEventListener('input', (e) => {
                    this.scale = parseFloat(e.target.value);
                    document.getElementById('scale-value').textContent = this.scale.toFixed(1);
                });
                
                document.getElementById('amplitude').addEventListener('input', (e) => {
                    this.amplitude = parseFloat(e.target.value);
                    document.getElementById('amplitude-value').textContent = this.amplitude.toFixed(2);
                });
                
                document.getElementById('timeScale').addEventListener('input', (e) => {
                    this.timeScale = parseFloat(e.target.value);
                    document.getElementById('timeScale-value').textContent = this.timeScale.toFixed(2);
                });
                
                document.getElementById('contrast').addEventListener('input', (e) => {
                    this.contrast = parseFloat(e.target.value);
                    document.getElementById('contrast-value').textContent = this.contrast.toFixed(1);
                });
                
                document.getElementById('animation').addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                    document.getElementById('animation-value').textContent = this.animationSpeed.toFixed(3);
                    console.log('Animation speed changed to:', this.animationSpeed);
                });
                
                document.getElementById('octaves').addEventListener('input', (e) => {
                    this.octaves = parseInt(e.target.value);
                    document.getElementById('octaves-value').textContent = this.octaves;
                });
            }
            
            // Multi-octave Perlin noise for debugging
            simpleNoise(x, y, octaves = 1) {
                // Grid coordinates
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                // Relative coordinates
                const xf = x - Math.floor(x);
                const yf = y - Math.floor(y);
                
                // Fade curves
                const u = xf * xf * xf * (xf * (xf * 6 - 15) + 10);
                const v = yf * yf * yf * (yf * (yf * 6 - 15) + 10);
                
                // Hash coordinates
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                
                // Simple gradient dot products
                const grad = (hash, x, y) => {
                    const h = hash & 3;
                    return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
                };
                
                // Interpolate
                const x1 = this.lerp(
                    grad(this.perm[A], xf, yf),
                    grad(this.perm[B], xf - 1, yf),
                    u
                );
                const x2 = this.lerp(
                    grad(this.perm[A + 1], xf, yf - 1),
                    grad(this.perm[B + 1], xf - 1, yf - 1),
                    u
                );
                
                // Multi-octave support
                if (octaves === 1) {
                    return this.lerp(x1, x2, v);
                }
                
                let total = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;
                
                for (let o = 0; o < octaves; o++) {
                    const octaveX = x * frequency;
                    const octaveY = y * frequency;
                    
                    // Recalculate for this octave
                    const oX = Math.floor(octaveX) & 255;
                    const oY = Math.floor(octaveY) & 255;
                    const oxf = octaveX - Math.floor(octaveX);
                    const oyf = octaveY - Math.floor(octaveY);
                    const ou = oxf * oxf * oxf * (oxf * (oxf * 6 - 15) + 10);
                    const ov = oyf * oyf * oyf * (oyf * (oyf * 6 - 15) + 10);
                    
                    const oA = this.perm[oX] + oY;
                    const oB = this.perm[oX + 1] + oY;
                    
                    const ox1 = this.lerp(
                        grad(this.perm[oA], oxf, oyf),
                        grad(this.perm[oB], oxf - 1, oyf),
                        ou
                    );
                    const ox2 = this.lerp(
                        grad(this.perm[oA + 1], oxf, oyf - 1),
                        grad(this.perm[oB + 1], oxf - 1, oyf - 1),
                        ou
                    );
                    
                    total += this.lerp(ox1, ox2, ov) * amplitude;
                    maxValue += amplitude;
                    
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                return total / maxValue;
            }
            
            lerp(a, b, t) {
                return a + t * (b - a);
            }
            
            getNoise(x, y, patternScale = 1.0) {
                // Apply scale - this is the key!
                // We want HIGHER scale values to create MORE repetitions
                const scaledX = x * this.scale * patternScale;
                const scaledY = y * this.scale * patternScale;
                // Time needs to be scaled down for reasonable animation speed
                const scaledTime = this.time * this.timeScale;
                
                // Debug time usage (only log occasionally)
                if (Math.random() < 0.0001) { // Log very rarely
                    console.log('getNoise time:', this.time.toFixed(3), 'scaledTime:', scaledTime.toFixed(3), 'animSpeed:', this.animationSpeed);
                }
                
                let nx = 0, ny = 0;
                
                switch (this.pattern) {
                    case 'perlin':
                        // Use time to animate the pattern
                        nx = this.simpleNoise(scaledX + scaledTime, scaledY, this.octaves);
                        ny = this.simpleNoise(scaledX + 100, scaledY + 100 + scaledTime, this.octaves);
                        break;
                        
                    case 'simplex':
                        // Simplified simplex-like pattern with time animation
                        nx = Math.sin((scaledX + scaledTime) * 2) * Math.cos(scaledY * 2);
                        ny = Math.cos((scaledX + scaledTime) * 2) * Math.sin((scaledY + scaledTime) * 2);
                        break;
                        
                    case 'voronoi':
                        // Simple voronoi-like pattern
                        const cellX = Math.floor(scaledX);
                        const cellY = Math.floor(scaledY);
                        const localX = scaledX - cellX;
                        const localY = scaledY - cellY;
                        const dist = Math.sqrt((localX - 0.5) * (localX - 0.5) + (localY - 0.5) * (localY - 0.5));
                        nx = (localX - 0.5) / (dist + 0.1);
                        ny = (localY - 0.5) / (dist + 0.1);
                        break;
                        
                    case 'waves':
                        // Wave interference with clear time animation
                        const wave1 = Math.sin(scaledX * 2 + scaledTime * 2);
                        const wave2 = Math.sin(scaledY * 2 - scaledTime * 2);
                        nx = wave1 * wave2;
                        ny = wave1 + wave2;
                        break;
                        
                    case 'turbulence':
                        // Turbulent pattern with octaves
                        let turb = 0;
                        let amp = 1;
                        for (let o = 0; o < this.octaves; o++) {
                            const freq = Math.pow(2, o);
                            turb += Math.abs(this.simpleNoise(scaledX * freq, scaledY * freq, 1)) * amp;
                            amp *= 0.5;
                        }
                        nx = turb;
                        ny = this.simpleNoise(scaledX + 50, scaledY + 50, this.octaves);
                        break;
                        
                    case 'flow':
                        // Flow field with rotating animation
                        const angle = Math.atan2(scaledY - 0.5, scaledX - 0.5) + scaledTime * 2;
                        nx = Math.cos(angle);
                        ny = Math.sin(angle);
                        break;
                        
                    default:
                        // Default to simple perlin with octaves and time animation
                        nx = this.simpleNoise(scaledX + scaledTime, scaledY, this.octaves);
                        ny = this.simpleNoise(scaledX + 100, scaledY + 100 + scaledTime, this.octaves);
                }
                
                // Apply contrast
                if (this.contrast !== 1.0) {
                    nx = Math.sign(nx) * Math.pow(Math.abs(nx), 1 / this.contrast);
                    ny = Math.sign(ny) * Math.pow(Math.abs(ny), 1 / this.contrast);
                }
                
                // Apply amplitude
                return {
                    x: nx * this.amplitude,
                    y: ny * this.amplitude
                };
            }
            
            renderCanvas(canvas) {
                const { ctx, scale, info, component } = canvas;
                const width = 200;
                const height = 200;
                
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                
                let min = Infinity, max = -Infinity;
                let sum = 0, sumSq = 0, count = 0;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Sample at normalized coordinates
                        const nx = x / width;
                        const ny = y / height;
                        
                        const noise = this.getNoise(nx, ny, scale);
                        
                        let value;
                        if (component === 'x') {
                            value = noise.x;
                        } else if (component === 'y') {
                            value = noise.y;
                        } else if (component === 'vector') {
                            // Skip for vector field
                            continue;
                        } else {
                            // Magnitude
                            value = Math.sqrt(noise.x * noise.x + noise.y * noise.y);
                        }
                        
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                        sum += value;
                        sumSq += value * value;
                        count++;
                        
                        // Map to grayscale
                        const gray = Math.floor((value + 1) * 127.5);
                        const index = (y * width + x) * 4;
                        
                        if (component === 'x' || component === 'y') {
                            // Show negative as red, positive as blue
                            if (value < 0) {
                                data[index] = Math.floor(-value * 255);
                                data[index + 1] = 0;
                                data[index + 2] = 0;
                            } else {
                                data[index] = 0;
                                data[index + 1] = 0;
                                data[index + 2] = Math.floor(value * 255);
                            }
                        } else {
                            data[index] = gray;
                            data[index + 1] = gray;
                            data[index + 2] = gray;
                        }
                        data[index + 3] = 255;
                    }
                }
                
                if (component === 'vector') {
                    // Draw vector field
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, width, height);
                    
                    const spacing = 10;
                    for (let y = spacing; y < height; y += spacing) {
                        for (let x = spacing; x < width; x += spacing) {
                            const nx = x / width;
                            const ny = y / height;
                            const noise = this.getNoise(nx, ny, scale);
                            
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate(Math.atan2(noise.y, noise.x));
                            
                            const mag = Math.sqrt(noise.x * noise.x + noise.y * noise.y);
                            ctx.strokeStyle = `hsl(${mag * 360}, 70%, 50%)`;
                            ctx.lineWidth = 1;
                            
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(spacing * 0.7 * mag, 0);
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }
                } else {
                    ctx.putImageData(imageData, 0, 0);
                }
                
                // Update info
                const mean = sum / count;
                const variance = (sumSq / count) - (mean * mean);
                document.getElementById(info).textContent = 
                    `Range: ${min.toFixed(2)} to ${max.toFixed(2)}`;
                
                return { min, max, mean, variance };
            }
            
            animate() {
                const prevTime = this.time;
                this.time += this.animationSpeed; // Controlled animation speed
                
                // Track frame count
                if (!this.frameCount) this.frameCount = 0;
                this.frameCount++;
                
                // Debug every 60 frames (about once per second)
                if (this.frameCount % 60 === 0) {
                    console.log('Animation debug:', {
                        time: this.time.toFixed(3),
                        animationSpeed: this.animationSpeed,
                        pattern: this.pattern,
                        scale: this.scale,
                        frameCount: this.frameCount
                    });
                }
                
                let globalMin = Infinity, globalMax = -Infinity;
                let globalVariance = 0;
                
                for (const canvas of this.canvases) {
                    const stats = this.renderCanvas(canvas);
                    if (stats) {
                        globalMin = Math.min(globalMin, stats.min);
                        globalMax = Math.max(globalMax, stats.max);
                        globalVariance = Math.max(globalVariance, stats.variance);
                    }
                }
                
                // Update global stats
                document.getElementById('min').textContent = globalMin.toFixed(3);
                document.getElementById('max').textContent = globalMax.toFixed(3);
                document.getElementById('range').textContent = (globalMax - globalMin).toFixed(3);
                document.getElementById('variance').textContent = globalVariance.toFixed(3);
                document.getElementById('time').textContent = this.time.toFixed(2);
                document.getElementById('frame').textContent = this.frameCount || 0;
                
                // Show warning if values are bad
                const warning = document.getElementById('warning');
                if (globalMax - globalMin < 0.1) {
                    warning.textContent = '⚠️ Pattern too uniform - increase scale or amplitude';
                } else if (globalVariance < 0.01) {
                    warning.textContent = '⚠️ Low variance - pattern may appear flat';
                } else {
                    warning.textContent = '';
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Preset configurations
        window.applyPreset = function(preset) {
            const presets = {
                smooth: { scale: 3, amplitude: 1.0, timeScale: 0.3, contrast: 1.0, animationSpeed: 0.01 },
                detailed: { scale: 8, amplitude: 1.2, timeScale: 0.5, contrast: 1.5, animationSpeed: 0.005 },
                cellular: { scale: 5, amplitude: 1.0, timeScale: 0.2, contrast: 2.0, animationSpeed: 0.02 },
                turbulent: { scale: 6, amplitude: 1.5, timeScale: 0.8, contrast: 1.2, animationSpeed: 0.03 }
            };
            
            const p = presets[preset];
            if (p) {
                document.getElementById('scale').value = p.scale;
                document.getElementById('amplitude').value = p.amplitude;
                document.getElementById('timeScale').value = p.timeScale;
                document.getElementById('contrast').value = p.contrast;
                document.getElementById('animation').value = p.animationSpeed || 0.01;
                
                document.getElementById('scale-value').textContent = p.scale.toFixed(1);
                document.getElementById('amplitude-value').textContent = p.amplitude.toFixed(2);
                document.getElementById('timeScale-value').textContent = p.timeScale.toFixed(2);
                document.getElementById('contrast-value').textContent = p.contrast.toFixed(1);
                document.getElementById('animation-value').textContent = (p.animationSpeed || 0.01).toFixed(3);
                
                window.debugger.scale = p.scale;
                window.debugger.amplitude = p.amplitude;
                window.debugger.timeScale = p.timeScale;
                window.debugger.contrast = p.contrast;
                window.debugger.animationSpeed = p.animationSpeed || 0.01;
                
                console.log('Preset applied:', preset, 'animationSpeed:', window.debugger.animationSpeed);
            }
        };
        
        // Initialize
        window.debugger = new SimpleNoiseDebugger();
    </script>
</body>
</html>